<html lang="en">
  <head>
<meta name="description" content="User interface of EEBench an open source, open access low cost
   oscilloscope and arbitrary waveform generator based on FPGA BASYS3 and nodejs JavaScript" />
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" type="text/css" href="../css/style.css" media="all" />
    <title>Serial A</title>
 <style>
.slidecontainer {
  width: 100%;
}

.slider {
  -webkit-appearance: none;
  width: 100%;
  height: 10px;
  background: #d3d3d3;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slider:hover {
  opacity: 1;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 10px;
  height: 20px;
  background: #0067a5;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 10px;
  height: 20px;
  background: #0067a5;
  cursor: pointer;
}

.nobr { white-space: nowrap }

table.bx { border-collapse: collapse; }

table.bo, tr.bo, th.bo, td.bo {  border: 1px solid black; border-collapse: collapse; padding-left: 10px; 
padding-right: 10px;
}

table.bo0, tr.bo0, th.bo0, td.bo0 { border: 3px solid black; border-collapse: collapse;}
table.bo1, tr.bo1, th.bo1, td.bo1 { border: 3px solid #FF8C00; border-collapse: collapse;}
table.bo2, tr.bo2, th.bo2, td.bo2 { border: 3px solid #0000FF; border-collapse: collapse;}
table.bo3, tr.bo3, th.bo3, td.bo3 { border: 3px solid #FF1493; border-collapse: collapse;}
table.bo4, tr.bo4, th.bo4, td.bo4 { border: 3px solid #008000; border-collapse: collapse;}
table.bo5, tr.bo5, th.bo5, td.bo5 { border: 3px solid #FF4500; border-collapse: collapse;}
table.bo6, tr.bo6, th.bo6, td.bo6 { border: 3px solid #4682B4; border-collapse: collapse;}
table.bo7, tr.bo7, th.bo7, td.bo7 { border: 3px solid #DC143C; border-collapse: collapse;}
table.bo8, tr.bo8, th.bo8, td.bo8 { border: 3px solid #ABABAB; border-collapse: collapse;}

table.tb, tr.tb, th.tb, td.tb { border: 3px solid black; background: #ABABAB; border-collapse: collapse;}
table.tbs, tr.tbs, th.tbs, td.tbs { border-top: 3px solid black; border-left: 3px solid black; 
border-right: 3px solid black; background: white; border-collapse: collapse;}
td.tbr:last-child { width:100%; border-bottom: 3px solid black; background: white; border-collapse: collapse;}
td.top {vertical-align: top;}

</style> 
  </head>
  
<!-- load socket.io Google -->
<script src="../node_modules/socket.io/client-dist/socket.io.js"></script>
<!-- load JQuery -->
<SCRIPT SRC="../scripts/jquery.js"> </SCRIPT>
<!-- load Chart module-->
   <script type="text/javascript" src="../Chart_2013_03_11/Chart_basic.js"></script>
<!-- load FFT module-->
  <script type="text/javascript" src="../FFT/dspFFT.js"></script>
  <body>
  <div id="headx" style="display:block">
  <div id="nheader1" style="background-color:#0067a5;color:#FFFFFF" align="right" >
     <a href="http://www.hochschule-kempten.de" style="color:#FFFFFF"> Hochschule Kempten &nbsp; &nbsp; &nbsp; </a>
  </div>
  <div id="nheader2" style="background-color:#05adb5;color:#FFFFFF" align="right" >
     <a href="http://www.hochschule-kempten.de/about-kempten-university/faculties/electrical-engineering.html?L=1" style="color:#FFFFFF">
	 Fakult&auml;t Elektrotechnik &nbsp; &nbsp; &nbsp;
  </div>
  <div id="nheader3" style="background-color:#f18700;color:#FFFFFF" align="right">
     <a href="Elektronik.html" style="background-color:#f18700;color:#FFFFFF"> 
	 Elektronik &nbsp; &nbsp; &nbsp;</a>
    <a href="http://www.hochschule-kempten.de/metanavigation/personen/detailansicht.html?typo3state=persons&lsfid=1000430" style="background-color:#f18700;color:#FFFFFF"> 
	 Fachgebiet Elektronik, Prof. Vollrath &nbsp; &nbsp; &nbsp;</a>
  </div>
  </div>
  <br>

<table class="bx" id="tabs">
<tr><td class="tbs" onclick="tabAct(0)">&nbsp;&nbsp;Configuration&nbsp;&nbsp; </td>
    <td class="tb" onclick="tabAct(1)">&nbsp;&nbsp;AWG1&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(2)">&nbsp;&nbsp;OSC&nbsp;&nbsp;</td>
	<td  class="tb" onclick="tabAct(3)">&nbsp;&nbsp;FFT&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(4)">&nbsp;&nbsp;Histogram&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(5)">&nbsp;&nbsp;Ramp&nbsp;Test&nbsp;INL,&nbsp;DNL&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(6)">&nbsp;&nbsp;Lookup&nbsp;Table&nbsp;&nbsp;</td>
	<td class="tbr"> &nbsp; &nbsp; </td></tr>
</table>

<!---------------------- Configuration ------------------------------------------->
<div id="tab0" class="tabX" style="display:block">
  <h2> Configuration </h2>
  <br>
  <table>
  <tr>
  <td> System:  Arduino MKR WIFI1010</td>
  </tr>
  <tr>
  <td> System: </td>
    <td>Communication:</td>
	<td id="com">Serial over USB (Serial NodeJs, StartServerAx.bat, ServerAx.bat)</td>
  </tr>
  </table>
  <table>
  <tr>
    <td>OSC1:</td>
	<td>
	  <select name="o1Config" id="o1Config" onchange="setConf()">
      <option value="0"> PMOD AD2</option>
     </select>
	</td>
    <td>OSC2:</td><td> Arduino pin A1</td>
    <td>OSC3:</td><td> Arduino pin A2</td>
    <td>OSC4:</td><td> Arduino pin A3</td>
  </tr>
  <tr>
    <td colspan="2">Averaging PMOD ADC</td>
	<td> 
	  <select name="avgADC" id="avgADC" onchange="setAvg()">
      <option value="1" selected>1</option>
      <option value="4">4</option>
      <option value="16">16</option>
     </select>
	</td>
    <td colspan="2">OSC Sampling time: </td>
	<td> <span id="timeSampling">1.3..4 ms</span>
    </td>
  </tr>
  <tr>
    <td>AWG1: Arduino A0</td>
	<td>
	  <select name="a10Config" id="a10Config" onchange="setConf()">
      <option value="0" selected>R2R</option>
      <option value="1">C serial</option>
     </select>
	  <select name="a11Config" id="a10Config" onchange="setConf()">
      <option value="0">None</option>
      <option value="3" selected>PMOD DA2</option>
     </select>
    </td>
    <td>AWG2:</td><td> None</td>
  </tr>
  <tr>
  <td> AWG1: </td>
    <td>Minimum voltage:</td>
	<td id="AWG1MinV"><input type="text" value="0 V" size="5" id="AWG1MinVVal" onkeyup=""/></td>
    <td>Maximum voltage:</td><td id="AWG1MaxV"><input type="text" value="3.3 V" size="5" id="AWG1MaxVVal" onkeyup=""/></td>
    <td>Resolution:</td><td id="AWG1Res"><input type="text" value="8" size="5" id="AWG1ResVal" onkeyup=""/> Bits</td>
  </tr>
  <tr>
  <td colspan="7"> <img src="../ImagesS/Arduino_MKR_WIFI_1010_ADCDAC.png" width="400"</td>
  </tr>
  </table>

  <span id="sCmd" onclick="sendCmdC()"><img src="ImagesS/Run.png" width="16"> Send Command  </span>
  <input type="text" value="X" size="40" id="cmdTxt"/>  <br>
  <div id="lCmd">Sent: </div>
  <br>
  <hr>
  <br>
<div id="dataX" style="display:block"></div>
  <br>
  <hr>
<div id="dataXYZ" style="display:block"></div>
  <br>
  <hr>
  <br>

Implemented commands with command example values according to Arduino DataConverterCharV6.ino sketch and 
StartServerAx.bat starting ServerAx.js:<br>
<br>
quiet: Disables console output of data sent to client<br> 
log: Enables console output of data sent to client<br> 
f&lt;nr&gt;: waveform<br>
     nr &lt;100 rectangle min code,max code<br>
     100 &lt;= nr &lt;200 ramp<br>
     200 &lt;=nr &lt;400 1 period sine<br>
     400 &lt;=nr &lt;600 11 period sine<br>
     600 &lt;=nr &lt;800 101 period sine<br>
     1001 period sine<br>
b sends correction table for binary weighted DAC 12 comma separated values (16 bit)<br>
     b256,34,8,0,0,0,0,0,0,0<br>
c sends 8 numbers vor osc1,2,3,4,awg10,11,awg20,21<br>
     c00001000 : the '1' activates serial DAC<br>
     c00000000 : the '0' activates R2R DAC<br>
t sends lookup table<br>
r sends range for AWG<br>
a send repeat averaging for MOD ADC<br> 
<br>
<br>
07.02.2025 Implemented serial DAC option and binary correction DataConverterCharV6.ino<br>
29.11.2023 Implemented Ramp test INL, DNL and lookup table transfer 
with DataConverterCharV4.ino<br>
Arduino acquisition is as fast as possible.<br> 
</div>

<!---------------------- Arbitrary Waveform Generator 1 ------------------------------------------->
<div id="tab1" class="tabX" style="display:none">
  <h2> Arbitrary Waveform Generator</h2>
 <table>
 <tr style="display:block"><td class="bo" colspan="2">
     <span id="aRun"  style="display:block" onclick="aOp('Run')"><img src="ImagesS/Run.png" width="16"> Run  </span>
	 <span id="aStop" style="display:none"  onclick="aOp('Stop')"><img src="ImagesS/Stop.png" width="16"> Stop </span> </td>
 </tr>
 <tr>
   <td class="bo" align="center" bgcolor="#99e6ff" onclick="setWave(0);" id="dc" style="display:none"><img src="ImagesS/DC.png" width="32"><br>DC</td>
   <td class="bo" align="center" bgcolor="#FFFFFF"  onclick="setWave(3);" id="triangle"><img src="ImagesS/Triangle.png" width="32"><br>Triangle</td>
   <td class="bo" align="center" bgcolor="#FFFFFF" onclick="setWave(1);" id="sine"><img src="ImagesS/Sine.png" width="32"><br>Sine</td>
   <td class="bo" align="center" bgcolor="#FFFFFF" onclick="setWave(2);" id="rect"><img src="ImagesS/Rect.png" width="32"><br>Pulse</td>
   <td class="bo" align="center" bgcolor="#FFFFFF"  onclick="setWave(4);" id="stair" style="display:none"><img src="ImagesS/Stair1.png" width="32"><br>Stair</td>
   <td rowspan="4" style="display:none"> <canvas id="Ausgangssignal" width="400" height="300">   </canvas></td>
 </tr>

<tr><td colspan="5">
<h3>Sine Frequency</h3>
<br>
     <select name="fxx" id="fxx" onchange="setWave(1)">
      <option value="300" selected> 1 period sine</option>
      <option value="500"> 11 period sine</option>
      <option value="1012"> 12 period sine</option>
      <option value="1015"> 15 period sine</option>
      <option value="1016"> 16 period sine</option>
      <option value="700"> 101 period sine</option>
      <option value="1256"> 256 period sine</option>
      <option value="900"> 1001 period sine</option>
      <option value="1000"> 8009 period sine</option>
     </select>
<br>
</td></tr>

 <tr style="display:none"><td colspan="5">
  <div id="frequency" class="sliderE">
  </div>
 </td>
 </tr>

 <tr style="display:block"><td colspan="5">
       <h4>Number of Codes</h4>                         <!--- name --->
 </td></tr>
</tr>
	 <tr><td colspan="3">  
	    <input type="range" min="1" max="255" step="1" value="255" class="slider" id="rangeSlider" width="300"
		  oninput="rangeVal.value = parseInt(rangeSlider.value)">
	 </td></tr>
	 <tr><td>Min</td><td align="center">Value </td><td align="right">Max</td></tr>
	 <tr><td>1</td><td align="center">
	    <input type="number" id="rangeVal" value="255" min="1" max="255"
		oninput="rangeSlider.value = parseInt(rangeVal.value)"></input> </td><td align="right">255</td></tr>

 <tr style="display:none"><td colspan="5">
  <div id="amplitude" class="sliderE">
  </div>
 </td></tr>

 <tr style="display:none"><td colspan="5">
  <div id="offset1" class="sliderE">
  <table style="display:none">       <!-- Slider --->
  <tr>
   <td colspan="5">
     <div id="off1" class="slidecontainer">
	   <h4>Offset </h4>                         <!--- name --->
	   <input type="range" min="0" max="100" step="2" value="1" class="slider" id="offset1Slider" width="300">
	 </div>
   </td>
  </tr>
  <tr><td>Min</td><td align="center" colspan="2">Value </td><td>Max</td></tr>
  <tr>
   <td>
   <div id="offset1MinCT" style="display:block">
   <input type="text" value="1 V" size="5" id="offset1Min" onkeyup="readCR(e,'offset1','V')"/>  
   <img src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox('offset1','Min','CB',1,'V')"><br>
   </div>
   <div id="offset1MinCB" style="display:none">
     <select name="offset1MinS" id="offset1MinS" onchange="comboBox('offset1','Min','CT',1,'V')">
      <option value="5 V"> 5 V</option>
      <option value="4 V"> 4 V</option>
      <option value="3 V"> 3 V</option>
      <option value="2 V"> 2 V</option>
      <option value="1 V"> 1 V</option>
      <option value="500 mV"> 500 mV</option>
      <option value="200 mV"> 200 mV</option>
      <option value="100 mV">100 mV</option>
       <option value="0 V" selected>0 V</option>
     </select>
   </div>
   </td>    <!--- actual value ---->       
   <td colspan="2" align="center">
     <div id="offset1ValCT" style="display:block">
     <input type="text" value="1 V" size="5" id="offset1Val"  onkeyup="readCR(e,'offset1','V')"/>  
     <img src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox('offset1','Val','CB',1,'V')">
     </div>
     <div id="offset1ValCB" style="display:none">
      <select name="offset1ValS" id="offset1ValS" onchange="comboBox('offset1','Val','CT',1,'V')">
       <option value="5 V"> 5 V</option>  <option value="4 V"> 4 V</option>
       <option value="3 V"> 3 V</option>  <option value="2 V"> 2 V</option>
       <option value="1 V"> 1 V</option>
       <option value="500 mV"> 500 mV</option>
       <option value="200 mV"> 200 mV</option>
       <option value="100 mV">100 mV</option>
       <option value="0 V">0 V</option>
      </select>
     </div>
   </td>
   <td>  
     <div id="offset1MaxCT" style="display:block">
     <input type="text" value="1 V" size="5" id="offset1Max"  onkeyup="readCR(e,'offset1','V')"/>  
     <img src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox('offset1','Max','CB',1,'V')"><br>
     </div>
     <div id="offset1MaxCB" style="display:none">
      <select name="offset1MaxS" id="offset1MaxS" onchange="comboBox('offset1','Max','CT',1,'V')">
       <option value="5 V"> 5 V</option>
       <option value="4 V"> 4 V</option>
       <option value="3 V"> 3 V</option>
       <option value="2 V"> 2 V</option>
       <option value="1 V" selected> 1 V</option>
       <option value="500 mV"> 500 mV</option>
       <option value="200 mV"> 200 mV</option>
       <option value="100 mV">100 mV</option>
       <option value="0 V">0 V</option>
      </select>
     </div>
    </td>
   </tr>
   </table>
   </div>
   </td>
</tr>

</table>
<br>
<div id="cmd"></div>
<div id="step"></div>
<br><br><br><br><br><br><br><br><br><br><br>
</div>

<!---------------------- Oscilloscope ------------------------------------------->
<div id="tab2" class="tabX" style="display:none">
  <h2> Oscilloscope</h2>
 <table class="bx">
 <tr><td class="bo" colspan="2">
     <span id="oRun"  style="display:block" onclick="oOp('Run')"><img src="ImagesS/Run.png" width="16"> Run  </span>
	 <span id="oStop" style="display:none"  onclick="oOp('Stop')"><img src="ImagesS/Stop.png" width="16"> Stop </span> </td>
 </tr>
 <tr><td class="bo">Acquisition </td><td class="bo">Average: 1</td>
     <td class="bo">Number of samples: 
	 	   <select id="dataMax" onclick="confOsc();">
   <!--   <option value="1" > 1</option> <option value="2"> 2</option>
      <option value="4" > 4</option> <option value="8"> 8</option>
      <option value="16" > 8 of 16</option>
	  <option selected value="512"> 256 of 512</option>
      <option value="1024" > 512 of 1024</option> 
	  <option value="2048"> 1024 of 2048</option>
      <option value="4096" >2048 of 4096</option> 
	  <option value="8192"> 4096 of 8192</option> -->
	  <option value="32768"> 16384</option>
     </select>
     </td>
     <td class="bo"> xy  x-axis
      <select name="xyAxis" id="xyAxis" onchange="changeXAxis()">
       <option value="0" selected> Time </option>
       <option value="1"> AWG1 </option>
       <option value="2"> C1 </option>
       <option value="3"> C2 </option>
       <option value="4"> C3 </option>
       <option value="5"> C4 </option>
	  </select>
	 </td>
     <td class="bo"> Unit:
      <select id="currUnit" onchange="changeUnit()">
       <option value="0" selected> Code </option> 
       <option value="1"> Voltage </option>
	  </select>
	 </td>
 </tr>
 <tr style="display:none">
   <td class="bo">Trigger</td>
   <td class="bo">Source &nbsp; 
      <select name="trgSrc" id="trgSrc">
       <option value="1"> AWG1 </option>
       <option value="2"> C1 </option>
       <option value="3"> C2 </option>
       <option value="4"> C3 </option>
       <option value="5"> C4 </option>
	  </select>
   </td>
   <td class="bo">Condition &nbsp; 
      <select name="trgEdge" id="trgEdge">
       <option value="1"> Rising </option>
       <option value="2"> Falling </option>
       <option value="3"> Ramp up </option>
	  </select>
   </td>
   <td class="bo"><table><tr><td>Level</td><td>
     <input type="text" value="1 V" size="5" id="trigLevelVal"></td><td>
	 <img id="trigLevelValCT" style="display:block" src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox('trigLevel','Val','CB',0,'V')">
	 <span id="trigLevelValCB" style="display:none">
      <select name="trigLevelValS" id="trigLevelValS" onchange="comboBox('trigLevel','Val','CT',0,'V')">
       <option value="3 V" > 3 V</option>
       <option value="2 V" > 2 V</option>
       <option value="1 V" selected > 1 V</option>
       <option value="500 mV"> 500 mV</option>
     </select>
     </span>  </td></tr>
	 </table> 
   </td>
 </tr>
</table>
<table>
<tr>
<td  class="top">
 <table>
 <tr> <td>X Axis</td></tr>
 <tr> <td class="bo0" id="time"><input type="checkbox" id="cTime" value="value" checked> Time<br>
 	    <table><tr><td>
		  Position: </td><td><input type="text" value="0 s" size="5" id="posVal" onkeyup="readCRX(e,'pos','s')"></td><td> 
		  <img id="posValCT" style="display:block" src="ImagesS/SelectListA.png" width="16" height="16" 
		       onclick="comboBox('pos','Val','CB',2,'s')">
          <div id="posValCB" style="display:none">
          <select id="posValS" onchange="comboBox('pos','Val','CT',2,'s')"></select>
		  </div>
		  </td></tr>
		  <tr><td>Base: </td><td><input type="text" value="200 us/div" size="5" id="baseVal" onkeyup="readCRX(e,'base','s/div')"></td><td> 
		  <img id="baseValCT" style="display:block" src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox('base','Val','CB',2,'s')">
          <div id="baseValCB" style="display:none">
          <select id="baseValS" onchange="comboBox('base','Val','CT',2,'s')"></select>
          </div>
		  </td></tr>
		  </table>
 </td></tr>
 <tr> <td>=====&nbsp;Y&nbsp;Axis&nbsp;&nbsp;===========</td></tr>
 <tr> <td class="bo1" id="AWG1">
        <input type="checkbox" id="cAWG1" value="value" checked onclick="toggleCheck('AWG1',1)">
	      AWG1 Unit: 
	  </td></tr>
 <tr> <td class="bo2" id="C1">
        <input type="checkbox" id="cC1" value="value">
	      C1
	  </td></tr>
 <tr> <td class="bo3" id="C2">
        <input type="checkbox" id="cC2" value="value">
	      C2</td></tr>
 <tr> <td class="bo4" id="C3">
        <input type="checkbox" id="cC3" value="value">
	      C3</td></tr>
 <tr> <td class="bo5" id="C4">
        <input type="checkbox" id="cC4" value="value">
	      C4</td></tr>
 <tr> <td class="bo6" id="M1">
        <input type="checkbox" id="cM1" value="value">
	      M1</td></tr>
 </table>
</td> 
   <td class="top" rowspan="6"> 
   <table>
   <tr><td class="bo1" onclick="activeChan(1)">AWG</td><td class="bo2" onclick="activeChan(2)">C1</td>
       <td class="bo3" onclick="activeChan(3)">C2</td><td class="bo4" onclick="activeChan(4)">C3</td>
	   <td class="bo5" onclick="activeChan(5)">C4</td><td class="bo6" onclick="activeChan(6)"> M1</td>
	   <td> <div id="statusOSC"></div></td>
   </tr>
   </table>
            <canvas id="OSC" width="600" height="350"></canvas><br>
			<span id="mouse">Mouse</span>
			<span id="dataXY">Data XY</span>
			</td>
<td class="top">
 <div id="measureOSC"></div>
</td> 

</tr>
</table>
<span style="background-color:#cce6ff;" onclick="generateData()">Load data</span>&nbsp;&nbsp; 
<span style="background-color:#cce6ff;" onclick="saveData()">Save data</span><br>
<br>
C1 PMOD ADC, C2 A1 Arduino, C3 A2 Arduino R2R, C4 A3 Arduino PMOD DAC <br>
Offset, range list<br>
connect input to chart<br>
X,Y Cursors<br>
Math function, Fit function<br>
<div id="data" style="display:block"></div>
</div>

<!---------------------- FFT --------------------------------------------------------->
<div id="tab3" class="tabX" style="display:none">
<h2>FFT</h2>
 <table class="bx">
 <tr><td class="bo">
     <span id="fRun"  style="display:block" onclick="fOp('Run')"><img src="ImagesS/Run.png" width="16"> Run  </span>
	 <span id="fStop" style="display:none"  onclick="fOp('Stop')"><img src="ImagesS/Stop.png" width="16"> Stop </span> </td>
 </tr>
  <tr>
   <td class="bo">Channel &nbsp; 
      <select name="fftSrc" id="fftSrc" onclick="calcHarmonics()">
       <option value="1"> AWG1 </option>
       <option value="2"> C1 </option>
       <option value="3"> C2 </option>
       <option value="4"> C3 </option>
       <option value="5"> C4 </option>
	  </select>
   </td>
  </tr>
  <tr>
   <td class="bo">FFT point reduction &nbsp; 
      <select name="fftPts" id="fftPts" onclick="generateFFT()">
       <option value="1"> 1 </option>
       <option value="2"> 2 </option>
       <option value="4"> 4 </option>
       <option value="8"> 8 </option>
       <option value="16"> 16 </option>
       <option value="32"> 32 </option>
       <option value="64"> 64 </option>
       <option value="128"> 128 </option>
       <option value="256"> 256 </option>
	  </select>
   </td>
  </tr>
  <tr>
  <td class="top"><div id="fftList">
     <table><tbody><tr><td>Magnitude List Channel: </td><td class="bo2">C1</td></tr></tbody></table>  
     <table border="1"><tbody><tr><td class="bo">Index</td><td class="bo">f in Hz</td><td class="bo"> signal<br> magnitude<br> dB</td><td class="bo"> Total<br> noise<br> magnitude<br> dB </td></tr>
	 </tbody></table>
  </div></td>
  <td class="top"> FFT Chart<br>  <canvas id="fftChart" width="600" height="350"></canvas><br>
  </td>
  </tr>
</table>

</div>

<!---------------------- Histogram --------------------------------------------------------->
<div id="tab4" class="tabX" style="display:none">
<h2>Histogram</h2>
 <table class="bx">
 <tr><td class="bo">
     <span id="hRun"  style="display:block" onclick="hOp('Run')"><img src="ImagesS/Run.png" width="16"> Run  </span>
	 <span id="hStop" style="display:none"  onclick="hOp('Stop')"><img src="ImagesS/Stop.png" width="16"> Stop </span> </td>
 </tr>
  <tr>
   <td id="bins" class="bo">Bins &nbsp; 
      <select name="binsVal" id="binsVal">
       <option value="16"> 16 </option>
       <option value="64"> 64 </option>
       <option value="256"> 256 </option>
       <option value="1024"> 1024</option>
       <option value="65536"> 65536 </option>
	  </select>
   </td>
 </tr>
  <tr>
  <td class="top"> Histogram<br>  <canvas id="histoChart" width="600" height="350"></canvas><br>
  <div id="binsTab"></div>
  </td>
  </tr>
</table>

</div>

<!---------------------- INL, DNL DAC --------------------------------------------------------->
<div id="tab5" class="tabX" style="display:none">
<h2>Ramp Test INL and DNL</h2>
<br>
Assuming first 4k data are a ramp.<br>
<br>
<table class="bx">
 <tr><td class="bo" colspan="2">
     <span id="rRun"  style="display:block" onclick="rOp('Run')"><img src="ImagesS/Run.png" width="16"> Run  </span>
	 <span id="rStop" style="display:none"  onclick="rOp('Stop')"><img src="ImagesS/Stop.png" width="16"> Stop </span> </td>
 </tr>
  <tr>
  <td class="bo">
  Step (Default 1):</td><td>
     <input type="text" value="1" size="6" id="codesStep"/>  </td>
    </tr>
  <tr><td class="bo">
    Start Code (Default 0): </td><td><input type="text" value="0" size="6" id="codesStart"/>  <br>
  </td>
  </tr>
  <tr><td class="bo">
    End Code (Default 255):</td><td><input type="text" value="255" size="6" id="codesEnd"/>  <br>
  </td>
  </tr>
  <tr>   <td class="bo">
      <input type="checkbox" id="cLook" value="value" > Calculate Lookup table<br> <!-- checked -->
     <input type="text" id="stepScale" value="1.0" > Maximum step scaling 0.66..1.0<br> <!-- Range 0.66..1.0 -->
	  Calculate for Channel &nbsp; 
      <select name="rampSrc" id="rampSrc" onclick="ramp()">
       <option value="1"> AWG1 </option>
       <option value="2"> C1 </option>
       <option value="3"> C2 </option>
       <option value="4"> C3 </option>
       <option value="5"> C4 </option>
	  </select>
   </td>
  </tr>
  <tr><td colspan="4">
    <div id="inlResult"></div>
    <canvas id="inlChart" width="800" height="350"></canvas>
    <canvas id="dnlChart" width="800" height="350"></canvas><br>
    <canvas id="rampChart" width="800" height="350"></canvas><br>
	Click on Chart to get a data table<br><br>
    <canvas id="rampX" width="800" height="350" style="display:none"></canvas>
    <canvas id="rampY" width="800" height="350" style="display:none"></canvas>
  </td>
  </tr>
</table>  
<div id="bestL"></div><br>
</div>

<!---------------------- Lookup Table --------------------------------------------------------->
<div id="tab6" class="tabX" style="display:none">
<h2>Lookup Table</h2>
<br> 
There should be 256 comma separated values in the text input field.<br>
<br>
<textarea id="lookupX" name="lookupX" rows="8" cols="128">
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255 
</textarea><br>
<input type="submit" value="Submit" onclick="sendLookup();"></input>
<br>
<input type="submit" value="Reset table" onclick="resetLookup();"></input><br>
<br>
<div style="display:none">
<h3>Example tables</h3>
Linear:<br>
<div id="linearT">0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,<br>
32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,<br>
64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,<br>
96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,<br>
128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,<br>
160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,<br>
192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,<br>
224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255</div>
<br>
Scrambled:<br>
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,<br>
64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,<br>
128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,<br>
192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,<br>
224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255, <br>
160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,<br>
96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,<br>
32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63<br>
<br>
MyLookup:<br>
<div id="myLookup"></div>
</div>
</div>

<div id="tab7" class="tabX" style="display:none">
<h2>Power supply</h2>
</div>

<div id="tab8" class="tabX" style="display:none">
<h2>Bodeplot</h2>
</div>

<div id="tab9" class="tabX" style="display:none">
<h2>Digital I/O</h2>
</div>

<div id="tab10" class="tabX" style="display:none">
<h2>Applications</h2>

IV curves: R, Diode, transistor, opamp, inverter<br>
Time operation: C, L, diode, transistor, inverter<br>
Bodeplot: passive and active Filters<br>
Power supply, SC circuits<br>
AD and DA converter<br>
Digital circuits, logic functions, multiplexer and encoder<br>
State machines, Counters, serializer and deserializer, memories<br> 
Microprocessors<br>
Digital signal processing and control loops<br>
</div>

<script>

 var srcX = ["AWG","OSC4", "OSC3","OSC2","OSC1"];
 var dataOSC = [];  // expecting 512 times 5 data points
 var dataIndex = 1;

var curveTyp = 1;
var e;      // event
var aXY = [];   // x y values AWG
var aGrN = 64;  // number of xy values AWG
var aState = "Stop";  // awg1 state
var oState = "Stop";  // oscilloscope state
var fState = "Stop";  // FFT state
var hState = "Stop";  // histogram state
var rState = "Stop";  // ramp test INl, DNL state
var busy = 0;
var timeBase = 0; // timeBase 0 every cycle, 1 every second cycle sampling cms send via sendCmdC cmdTxT.value
var trgPos = -1;  // Trigger position

// range
var voltRange = ["5 V","4 V","3 V","2 V","1 V","900 mV", "800 mV", "700 mV", "600 mV",
                 "500 mV","400 mV","300 mV","200 mV","100 mV","80 mV","60 mV","50 mV","0 V",
				 "-50 mV","-60 mV","-80 mV","-100 mV","-200 mV","-300 mV","-400 mV","-500 mV",
				 "-600 mV","-700 mV","-800 mV","-900mV","-1 V","-2 V","-3 V","-4 V","-5 V"];
var voltDivRange = ["5 V/div","4 V/div","3 V/div","2 V/div","1 V/div","500 mV/div", "100 mV/div",
                 "50 mV/div","10 mV/div","5 mV/div","1 mV/div","500 uV/div","100 uV/div"];
var timeRange = ["-1 s", "-500 ms", "-200 ms", "-100 ms", "-50 ms", "-20 ms","-10 ms", "-5 ms", 
                 "-2 ms", "-1 ms", "-500 us",  "-200 us", "-100 us", "-50 us",  "-10 us", "-5 us",
				 "0 s", "5 us", "10 us", "50 us", "100 us", "500 us", "1 ms", "5 ms", "10 ms",
				 "50 ms", "100 ms", "500 ms", "1 s"];
var timeBaseRange = ["1 s/div", "500 ms/div", "200 ms/div", "100 ms/div", "50 ms/div", "20 ms/div",
                 "10 ms/div", "5 ms/div", "2 ms/div", "1 ms/div", "500 us/div",  "200 us/div",
				  "100 us/div", "50 us/div",  "10 us/div", "5 us/div"];
var frequencyRange = ["5 MHz","2 MHz","1 MHz","500 kHz","200 kHz","100 kHz", "50 kHz", "20 kHz", "10 kHz",
                 "5 kHz","2 kHz","1 kHz","500 Hz","200 Hz","100 Hz","50 Hz","20 Hz","10 Hz",
				 "5 Hz","2 Hz","1 Hz","500 mHz","200 mHz","100 mHz","50 mHz","20 mHz",
				 "10 mHz","5 mHz","2 mHz","1mHz","500 uHz","200 uHz","100 uHz"];
var codeRange = [16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072];
var codePos = [-16,-32,-64,-128,-256,-512,-1024,-2048,-4096,-8192,-16384,-32768,-65536,-131072];

function tabAct(x) { // show only active tab
  // class tbs -> tb, x class member tb -> tbs
  var tabClass = document.getElementsByClassName("tbs");
  var tabClassDiv = document.getElementsByClassName("tabX");
  for (var i = 0; i < tabClass.length; i++) {
     tabClass[i].classList.add("tb");
     tabClass[i].classList.remove("tbs");
  }
  for (var i = 0; i < tabClassDiv.length; i++) {
	 tabClassDiv[i].style.display = "none";
  }
  // alert(x + "," + tabClass.length);
  tabClass = document.getElementsByClassName("tb");
  // alert(x + "," + tabClass.length);
  tabClass[x].classList.add("tbs");
  tabClass[x].classList.remove("tb");
  tabClassDiv[x].style.display = "block";

}

function setAvg() {  // set averaging
    var repeatX = parseInt(document.getElementById("avgPMOD").value);
	document.getElementById("cmd").innerHTML = "a" + awg1;
	sendCmd();        // send command
}

function setConf() {  // send configuration
    var txt ="c0000100000";
    var awg1 = parseInt(document.getElementById("a10Config").value);
	document.getElementById("cmd").innerHTML = "c0000" + awg1 + "000";
	sendCmd();        // send command
}

function aOp(cmd) {  // AWG operation
  if (cmd == "Run") {
    document.getElementById("aStop").style.display="block";
    document.getElementById("aRun").style.display="none";
	// Action 
    genCmdAWG();      // update command
	// check simulation?
	sendCmd();        // send command
	aState = "Run";
  } else {
    var cmdTemp =  document.getElementById("cmd").innerHTML;
    document.getElementById("cmd").innerHTML ="X";
    document.getElementById("aRun").style.display="block";
    document.getElementById("aStop").style.display="none";
	// Action missing
	sendCmd();
	document.getElementById("cmd").innerHTML = cmdTemp;
	aState = "Stop";
  }
}

var handlerOsc;
var busyOsc = 0;

function runOsc() {
   if (busyOsc == 0 ) {
     document.getElementById("cmd").innerHTML ="U";   // send command to send data
	 sendCmd();
	 busyOsc = 1;  // new data going on
   }	
}

function oOp(cmd) {  // oscilloscope reading
  var cmdTemp =  document.getElementById("cmd").innerHTML;
  if (cmd == "Run") {
    document.getElementById("cmd").innerHTML ="U";   // send command to send data
    document.getElementById("oStop").style.display="block";
    document.getElementById("oRun").style.display="none";
	// Action 
	sendCmd();
	oState = "Run";  
	dataIndex = 0;
	// handlerOsc = setTimeout(runOsc,2000);
	handlerOsc = setInterval(runOsc,2000);
  } else {
    // document.getElementById("cmd").innerHTML ="X";
    document.getElementById("oRun").style.display="block";
    document.getElementById("oStop").style.display="none";
	// Action
	// sendCmd();
	oState = "Stop";
	clearInterval(handlerOsc);
  }
  document.getElementById("cmd").innerHTML = cmdTemp;
}

function fOp(cmd) {  // oscilloscope reading
  if (cmd == "Run") {
    document.getElementById("fStop").style.display="block";
    document.getElementById("fRun").style.display="none";
    fState="Run";
	generateFFT();
  } else {
    document.getElementById("fStop").style.display="none";
    document.getElementById("fRun").style.display="block";
    fState="Stop";
  }
}

function hOp(cmd) {  // oscilloscope reading
  if (cmd == "Run") {
    document.getElementById("hStop").style.display="block";
    document.getElementById("hRun").style.display="none";
    hState="Run";
	generateHisto();
  } else {
    document.getElementById("hStop").style.display="none";
    document.getElementById("hRun").style.display="block";
    hState="Stop";
  }
}

function rOp(cmd) {  // oscilloscope reading
  if (cmd == "Run") {
    document.getElementById("rStop").style.display="block";
    document.getElementById("rRun").style.display="none";
    // hState="Run";
	// generateHisto();
    rState="Run";
  } else {
    document.getElementById("rStop").style.display="none";
    document.getElementById("rRun").style.display="block";
    rState="Stop";
  }
}

function readCR(key,id,unit) {
	if (!key) {	key = event; key.which = key.keyCode; }
	if (key.which == 13) { updateSlider(id,unit);}
}

function readCRH(key,id,unit) {
	if (!key) {	key = event; key.which = key.keyCode; }
	if (key.which == 13) { generateHisto();}
}

function setWave(nr) {
  // alert(nr);
  var wNames = ["dc","sine","rect","triangle","stair"];
  curveTyp = nr;
  for (var i = 0; i < wNames.length; i++) {
     if (i == nr) {
       document.getElementById(wNames[i]).style.backgroundColor = "#99e6ff";
	 } else {
       document.getElementById(wNames[i]).style.backgroundColor = "#FFFFFF";
     }	 
  }
  // Missing disable Frequency Amplitude for DC
  plotAWG();
  genCmdAWG();
}


// Evaluates a text input with arrow with list id=offset1Min, offset2Min 
function comboBox(id,minmax,nr,slider,unit) {
  if (nr == "CT") {    // activate text input
    document.getElementById(id + minmax + "CT").style.display="block";
    document.getElementById(id + minmax + "CB").style.display="none";
	// change selected value in List 
	document.getElementById(id + minmax).value = document.getElementById(id + minmax + "S").value; 
  } else {          // activate List
    document.getElementById(id + minmax + "CT").style.display="none";
    document.getElementById(id + minmax + "CB").style.display="block";
	// change value in text input 
	var valX = findNextOption(id + minmax + "S",document.getElementById(id + minmax).value);
	document.getElementById(id + minmax + "S").value = valX;  
	if  (((minmax == "Max") && (document.getElementById(id + "Val").value > valX) ) 
	     || ((minmax == "Min") && (document.getElementById(id + "Val").value < valX) )){
	    document.getElementById(id + "Val").value = valX;
	}	
  }
  if (slider == 1) { updateSlider(id,unit); }
  if (slider == 2) {  // update oscillocope callback better??
     // like  readCRX 
     updateOSC()
  }  
  if (slider == 3) { generateHisto(); }
}

function unitToValue(txtV) {
  var text = txtV.split(" ");  // number and unit
  // alert("x" + txtV + "x");
  var scale = 1;
  if (text.length == 0) {
    text[0] = "0";
  } else if (text.length > 1) {
    var unit = text[1].substring(0,1); // get unit
    if (unit == "T") { scale = 1E12; }
    else if (unit == "G") { scale = 1E9; }
    else if (unit == "M") { scale = 1E6; }
    else if (unit == "k") { scale = 1E3; }
    else if (unit == "m") { scale = 1E-3; }
    else if (unit == "u") { scale = 1E-6; }
    else if (unit == "n") { scale = 1E-9; }
    else if (unit == "p") { scale = 1E-12; }
  }
  return parseFloat(text[0])*scale;
}

function valueToUnit(val) {
    var valabs = Math.abs(val);
	var scale = 1;
	var mod ="";
    if (valabs >= 1E12) { mod = "T"; scale = 1E12; }
    else if (valabs >= 1E9) { mod = "G"; scale = 1E-9; }
    else if (valabs >= 1E6) { mod = "M"; scale = 1E-6; }
    else if (valabs >= 1E3) { mod = "k"; scale = 1E-3; }
    else if (valabs >= 1) { mod = ""; scale = 1; }
    else if (valabs >= 1E-3) { mod = "m"; scale = 1E3; }
    else if (valabs >= 1E-6) { mod = "u"; scale = 1E6; }
    else if (valabs >= 1E-9) { mod = "n"; scale = 1E9; }
    else if (valabs >= 1E-12){ mod = "p"; scale = 1E12; }
    else { mod = ""; scale = 0; }
	return (val*scale).toPrecision(3) + " " + mod;
}

function findNextOption(optionId,valueU) {
  var selectBoxEl = document.getElementById(optionId);
  var arrayOfNodes = selectBoxEl.childNodes;
  var optionsArr = [];
  // loop through child Nodes and only get option nodes
  for (var i = 0; i < arrayOfNodes.length; i++) {
	if (arrayOfNodes[i].nodeName === 'OPTION') {
  	  optionsArr.push(arrayOfNodes[i].value);
    }
  }
  // alert(optionsArr);
  var select = optionsArr[0];
  var delta = Math.abs(unitToValue(optionsArr[0]) - unitToValue(valueU) );
  for (var i = 1; i < optionsArr.length; i++) {
     var delta1 = Math.abs(unitToValue(optionsArr[i]) - unitToValue(valueU) );
	 if (delta1 < delta) {
	    select = optionsArr[i];
		delta = delta1;
	 }
  }
  return select;
}


function updateSlider(id,unit) { // From Min Value Max list limit Value
    // Min update slider
	var minXE = unitToValue(document.getElementById(id+"Min").value);
	// alert(minXE);
	document.getElementById(id+"Slider").min = minXE
    // Max update slider
	var maxXE = unitToValue(document.getElementById(id+"Max").value);
	if (maxXE < minXE) {   // Max greater than Min
	    maxXE = minXE; 
		document.getElementById(id+"Max").value = valueToUnit(maxXE) + unit;
	}
	document.getElementById(id+"Slider").max = maxXE
    // Step
	document.getElementById(id+"Slider").step = (maxXE - minXE)/50;
	// value
	var val = unitToValue(document.getElementById(id + "Val").value);
	document.getElementById(id + "Slider").value = val;
	if (val > maxXE) { val = maxXE; }
	if (val < minXE) { val = minXE; }
    // position	
	document.getElementById(id + "Slider").value = val;
	document.getElementById(id + "Val").value = valueToUnit(val) + unit;
	// update curve
	plotAWG();
}

function slider(id,unit) {
var dslider = document.getElementById(id+"Slider");		//Slider
var d = document.getElementById(id + "Val");
  d.value = valueToUnit(dslider.value) + unit;          // update Value
  dslider.oninput = function(){
	d.value = valueToUnit(this.value) + unit;
	// update graph
    plotAWG();
  }
}


function createSlider(id,range,unit) { // Misisng unit V HZ and range name function comboBox readCR
var xList = ["Min","Val","Max"];
var nSlider = document.getElementById(id);		// create Slider with min, value max
var innerTxt = "<table>\n"      
             + " <tr>"
             + "<td colspan='4'>"       
	         + "<div id='off1' class='slidecontainer'>"
	         + "<h4>" + id[0].toUpperCase() + id.substring(1) + "</h4>"
	         + '<input type="range" min="' + unitToValue(range[range.length - 1]) + '" max="' + unitToValue(range[0]) 
			 + '" step="2" value="' + unitToValue(range[Math.trunc(range.length/2)]) + '" class="slider" id="' + id + 'Slider" width="300">'
	         + '</div>'
             + '</td>'
             + '</tr>'
             +' <tr><td>Min</td><td align="center">Value </td><td>Max</td></tr>'
             + '<tr>';
	for (var j = 0; j < xList.length; j++) {
      var valX = range[range.length - 1];
	  if (xList[j] == "Val") valX = range[Math.trunc(range.length/2)];
	  if (xList[j] == "Max") valX = range[0];
      innerTxt = innerTxt + '<td>'
             + '<div id="' + id + xList[j] +'CT" style="display:block">'
             + '<input type="text" value="' + valX + '" size="5" id="' + id + xList[j] + '" onkeyup="readCR(e,' + "'" + id +"','" + unit + "'" +')"/>\n'  
             + '<img src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox(' + "'" + id + "'" + ',' + "'" 
			  + xList[j] + "'" +','+ "'" + 'CB' + "'" +',1,'+ "'" + unit + "'" + ')">'
             + '</div>'
             + '<div id="' + id + xList[j] + 'CB" style="display:none">'
             + '<select name="' + id + xList[j] + 'S" id="' + id + xList[j] + 'S" onchange="comboBox('+ "'" + id + "','" 
	               + xList[j] + "','"+'CT' + "',1,'" + unit + "')" +'">';
      for (var i = 0; i < range.length; i++) {
         innerTxt +='<option value="' + range[i] + '" >' + range[i] + '</option>';
      }			 // Value combo box
      innerTxt = innerTxt + '</select>'
             + '</div>'
             + '</td>';       
    }
    innerTxt = innerTxt + '</tr></table>'
	nSlider.innerHTML = innerTxt;
}

function createComboBox(name,id,range,unit,slider) {
var nCombo = document.getElementById(id);		// create ComboBox only
var valX = range[range.length - 1];
var selX = "";

var innerTxt = "<table>\n"      
             + " <tr><td>" + name + "</td>";
    innerTxt = innerTxt + '<td>'
             + '<div id="' + id +'ValCT" style="display:block">';
    if (slider == 3) {          // no update slider with readCR
	  innerTxt += '<input type="text" value="' + valX + '" size="5" id="' + id + 'Val" onkeyup = "readCRH(e,' + "'" + id +"','" + id +"'" +')"/>\n'  
    } else {
	  innerTxt += '<input type="text" value="' + valX + '" size="5" id="' + id + 'Val" onkeyup = "readCR(e,' + "'" + id +"','" + id +"'" +')"/>\n'  
    }
	innerTxt += '<img src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox(' + "'" + id + "'" + ',' + "'" 
			 + "Val'" +','+ "'" + 'CB' + "'" +',' + slider + ','+ "'" + unit + "'" + ')">'
             + '</div>'
             + '<div id="' + id + 'ValCB" style="display:none">'
             + '<select name="' + id + 'ValS" id="' + id + 'ValS" onchange="comboBox('+ "'" + id + "','" 
	               + "Val','"+'CT' + "','" + slider + "','" + id +"')" +'">';
      for (var i = 0; i < range.length; i++) {                  // create options from range
		 innerTxt +='<option value="' + range[i] + '" >' + range[i] + '</option>';
      }			 // Value combo box
      innerTxt = innerTxt + '</select>'
             + '</div>'
             + '</td>';       
    innerTxt = innerTxt + '</tr></table>'
	nCombo.innerHTML = innerTxt;
}

window.addEventListener("load",createSlider('amplitude',voltRange,'V'));
window.addEventListener("load",createSlider('frequency',frequencyRange,'Hz'));
window.addEventListener("load",slider('offset1','V'));
window.addEventListener("load",updateSlider('offset1','V'));
window.addEventListener("load",slider('amplitude','V'));
window.addEventListener("load",updateSlider('amplitude','V'));
window.addEventListener("load",slider('frequency','Hz'));
window.addEventListener("load",updateSlider('frequency','Hz'));
window.addEventListener("load",setWave(1));

// window.addEventListener("load",alert(findNextOption('offset1ValS','100 mV')));
function decToHex(x,d) {
   var hexN = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"];
   var hex = "";
   var num = Math.round(x);
   var div;
   var rest;
   for (var i = 0; i < d; i++) {    //  8 hex digits
       div = Math.trunc(num/16);
	   rest = num % 16;
	   // alert(num +"x" + div + "x" + rest);
	   hex = hexN[rest] + hex;
	   num = div;
   }
   return hex;
}

function DecHexValue(x) {
 if (x=="A") { return 10; } else if (x=="B") {  return 11;
 } else if (x=="C") { return 12; } else if (x=="D") {  return 13;
 } else if (x=="E") {return 14; } else if (x=="F") {  return 15;
 } else { return parseInt(x); }
}

function hexToDec(x) {
   var hexN = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"];
   var dec = 0;
   for (var i = 0; i < x.length; i++) {    //  8 hex digits
      dec = dec * 16 + DecHexValue(x[i]); 
   }
   return dec;
}

function genCmdAWG() {  // generate serial command for Arduino
  var cmd = "";
  var maxV = 3.3;
  var maxC = 32767;
  var fCalc = 1E8; // 100 MHz update of calculation
  var frequency = unitToValue(document.getElementById("frequencyVal").value);
  var amp = parseInt(rangeVal.value) * 16; // amp 12 bit value arduino unitToValue(document.getElementById("amplitudeVal").value);
  var off = unitToValue(document.getElementById("offset1Val").value);
  var fxx = document.getElementById("fxx").value;
 
  var start;   // Triangle parameters
  var stop;
  var step;
  var repeat;
  var ampC;
  var offC;
	if (curveTyp == 0) {  // DC
	   cmd = "T"; // triangle 
	   start = Math.trunc(maxC / maxV * off);
       cmd = cmd + 	decToHex(start,4);   
       cmd = cmd + 	decToHex(start,4);  // stop =start DC   
       cmd = cmd + 	"0001";     
       cmd = cmd +  "00020000";  // doesn't matter
	} else if (curveTyp == 1) {  // Sine
	   cmd = "f"; // Sine
	   ampC = Math.trunc( (2*1024*1024*1024-1) / maxV * amp);
       offC = Math.trunc( (2*1024*1024*1024-1) / maxV * off);
       if (offC >= 2*1024*1024*1024) { offC = 2*1024*1024*1024-1; }
	   if ((offC + ampC) >= 2*1024*1024*1024) { ampC = 2*1024*1024*1024-1-offC; } 	   
	   if ((offC - ampC) < 0) { ampC = offC; }
	   start = 0;
	   stop = 4095;
	   step = Math.trunc(1024*1024*1024/(fCalc/13/frequency));
	   // step = 100900;
	   cmd = cmd + 	decToHex(step,8);   // amplitude
       cmd = cmd + 	decToHex(ampC,8);   // amplitude
       cmd = cmd + 	decToHex(offC,8);  // offset
       cmd = "f" + fxx + "_r" + amp;                // overwrite	   
	} else if (curveTyp == 2) {  // Pulse
	   cmd = "f"; // PULSE
	   start = Math.trunc(maxC / maxV * (off-amp));  // start voltage to code
	   stop = Math.trunc(maxC / maxV * (off+amp));   // stop voltage to code
	   if (start < 0) start = 0;                     // no negative code
	   if (stop > maxC) stop = maxC;                 // stop limited by maximum code
	   step = stop - start;                          // adjust step to difference
	   repeat = Math.trunc(1 / frequency / 2 * fCalc);    // 1E8 fFPGA 
       cmd = cmd + 	decToHex(start,4);   
       cmd = cmd + 	decToHex(stop,4);  // stop =start DC   
       cmd = cmd + 	decToHex(step,4);     
       cmd = cmd +  decToHex(repeat,8);  // frequency
       cmd = "f50" + "_r" + amp;                // overwrite	   
   	} else if (curveTyp == 3) {  // Triangle 
	   var repMax = 64;          // When does step change from 1 to another number
	   cmd = "t"; // triangle 
	   start = Math.trunc(maxC / maxV * (off-amp));
	   stop = Math.trunc(maxC / maxV * (off+amp));
	   if (start < 0) start = 0;
	   if (stop > maxC) stop = maxC;
	   repeat = 1 / frequency / (stop-start) / 2 * fCalc;    // 1E8 fFPGA 
	   // alert(repeat);
	   if (repeat >= repMax) { 
	      repeat = Math.trunc(repeat); 
	      step = 1;
	   } else {	   
	      step = Math.trunc(repMax / repeat);
		  stop = Math.trunc((stop-start)/step)*step + start;
		  repeat = repMax;
	   }	  
	   cmd = cmd + 	decToHex(start,4);   
       cmd = cmd + 	decToHex(stop,4);  // stop =start DC   
       cmd = cmd + 	decToHex(step,4);     
       cmd = cmd +  decToHex(repeat,8);  // frequency
       cmd = "f100" + "_r" + amp;                // overwrite	   
	} else if (curveTyp == 4) {  // Stair   
	   cmd = "x"; // triangle 
	   start = Math.trunc(maxC / maxV * (off-amp));
	   stop = Math.trunc(maxC / maxV * (off+amp));
	   if (start < 0) start = 0;
	   if (stop > maxC) stop = maxC;
	   repeat = Math.trunc(1 / frequency / 2 * fCalc / 5);    // 1E8 fFPGA 
       if (repeat == 0) { 
	      repeat = 1;      // ??	   
	   } else {	   
	      step = Math.trunc((stop-start)/5);
		  stop = Math.trunc((stop-start)/step)*step + start;
	   }	  
	   cmd = cmd + 	decToHex(start,4);   
       cmd = cmd + 	decToHex(stop,4);  // stop =start DC   
       cmd = cmd + 	decToHex(step,4);     
       cmd = cmd +  decToHex(repeat,8);  // frequency
	}
	document.getElementById("cmd").innerHTML = cmd;
	document.getElementById("step").innerHTML = "Start: " + start + " Stop: " + stop
	   + " Step: " + step + " Repeat: " + repeat;
}

function plotAWG() {
  // curveTyp  global variable 0 DC, 1 Sine, 2 rect, 3 Triangle 
  var xStart, xStop, xStep;
  var yAmp, yOff; 
  
  xStart = 0;
  xStop = 1/unitToValue(document.getElementById("frequencyVal").value);
  xStep = (xStop - xStart)/aGrN;
  yAmp = unitToValue(document.getElementById("amplitudeVal").value);
  yOff = unitToValue(document.getElementById("offset1Val").value);
  
  for (var i = 0; i < aGrN; i++) {		
	aXY[i] = i*xStep;
	if (curveTyp == 0) {
	   aXY[i+aGrN] = yOff;
	} else if (curveTyp == 1) {   
	   aXY[i+aGrN] = yOff + yAmp * Math.sin(i / aGrN * 2 * Math.PI);
	} else if (curveTyp == 2) {   
	   if (i < aGrN/2) {
	     aXY[i+aGrN] = yOff + yAmp;
	   } else {
	     aXY[i+aGrN] = yOff - yAmp;
	   }
	} else if (curveTyp == 3){  // Triangle
	   if (i < aGrN/4) {
	     aXY[i+aGrN] = yOff + yAmp * i * 4 / aGrN;
	   } else if (i < 3/4*aGrN) {
	     aXY[i+aGrN] = yOff + yAmp - yAmp * (i - aGrN / 4) * 4 / aGrN;
       } else {
	     aXY[i+aGrN] = yOff - yAmp + yAmp * (i - 3/4 * aGrN) * 4 / aGrN;
	   }
	} else {  // Stair
	   if (i < aGrN/10) {
	     aXY[i+aGrN] = yOff - yAmp;
	   } else if (i < 2/10*aGrN) {
	     aXY[i+aGrN] = yOff - yAmp * 3 / 5;
       } else if (i < 3/10*aGrN) {
	     aXY[i+aGrN] = yOff - yAmp * 1 / 5;
       } else if (i < 4/10*aGrN) {
	     aXY[i+aGrN] = yOff + yAmp * 1 / 5;
	   } else if (i < 5/10*aGrN) {
	     aXY[i+aGrN] = yOff + yAmp * 3 / 5;
	   } else if (i < 6/10*aGrN) {
	     aXY[i+aGrN] = yOff + yAmp;
	   } else if (i < 7/10*aGrN) {
	     aXY[i+aGrN] = yOff + yAmp * 3/ 5;
	   } else if (i < 8/10*aGrN) {
	     aXY[i+aGrN] = yOff + yAmp * 1/5;
	   } else if (i < 9/10*aGrN) {
	     aXY[i+aGrN] = yOff - yAmp * 1/5;
	   } else {
	     aXY[i+aGrN] = yOff - yAmp * 3/5;
	   }
    }	
  }
  ScatterPlot("Ausgangssignal","Signal",aXY,aGrN,
		      "time","lin","minmax",
			  "Amplitude","lin","auto","Fine");
   genCmdAWG();
   if (aState == "Run") {
	  sendCmd();
   }
}

// window.addEventListener("load",Inputsignal ());

//----------------------------------------------------------------------------------//
//-------------------- Oscilloscope    ---------------------------------------------//
//----------------------------------------------------------------------------------//
var mouseX = 0;

var channels = new Array();
			  
// creates HTML entries for C1, C2, C3, C4, M1
function createChannel(baseId, checked, index, unit) {
   var sel = 1;
	var objTxt  ='<input type="checkbox" id="c' + baseId +'" value="value" ' + checked 
	            + ' onclick="toggleCheck(' + "'" + baseId + "'" + ',' + index + ')">';
	   objTxt += baseId; 
	   if (unit == 1) {
	     objTxt += ' Unit:'; 
	     objTxt += '<select id="unit' + baseId +'" >';
	     // <option value="W" onclick="changeUnitX('AWG1','')">W</option>
         objTxt += '<option value="count" onclick="changeUnitX(' +"'" + baseId + "',''" + ')">Count</option>';
         objTxt += '<option value="V" selected onclick="changeUnitX(' + "'" + baseId + "','V'" +')">V</option>';
         objTxt += '<option value="A" onclick="changeUnitX(' + "'" + baseId + "','A'" + ')">A</option>';
         objTxt += '<option value="O" onclick="changeUnitX(' + "'" + baseId + "','&Omega;'" + ')">&Omega;</option>';
         objTxt += '<option value="W" onclick="changeUnitX(' + "'" + baseId + "','W'" + ')">W</option>';
         objTxt += '</select><br>';
	   }	 
	if (checked == "checked") objTxt += '<table id="tab' + baseId +'" style="display:block"><tr><td>'
	else { 
	  objTxt += '<table id="tab' + baseId +'" style="display:none"><tr><td>';
	  sel = 0;
	}  
	   objTxt += 'Offset: </td><td><input type="text" value="0 V" size="5" id="off' + baseId +'Val" onkeyup="readCRX(e,' + "'off" + baseId + "','s')" + '"></td><td>'; // missing onkeyup 
	   objTxt += '<img id="off' + baseId + 'ValCT" style="display:block" src="ImagesS/SelectListA.png" width="16" height="16"' 
	           + 'onclick="comboBox('+ "'off" + baseId + "','Val','" + 'CB' + "',2,'V')" +'">';
       objTxt += '<div id="off'  + baseId + 'ValCB" style="display:none">';
       objTxt += '<select id="off'  + baseId + 'ValS" onchange="comboBox('+ "'off" + baseId + "','Val','"
		        + 'CT' + "',2,'V')" +'"></select>';
	   objTxt += '</div>';
	   objTxt += '</td></tr>';
	   objTxt += ' <tr><td>Range: </td><td><input type="text" value="1 V/div" size="5" id="range' + baseId + 'Val" onkeyup="readCRX(e,' + "'range" + baseId + "','s')" + '"></td><td>';; // missing onkeyup
	   objTxt += '  <img id="range' + baseId +'ValCT" style="display:block" src="ImagesS/SelectListA.png" width="16" height="16"'
                + 'onclick="comboBox('+ "'range" + baseId + "','Val','" + 'CB' + "',2,'V/div')" +'">';
       objTxt += '<div id="range'  + baseId + 'ValCB" style="display:none">';
       objTxt += '<select id="range'  + baseId + 'ValS" onchange="comboBox('+ "'range" + baseId + "','Val','"
		        + 'CT' + "',2,'V/div')" +'"></select>';
	   objTxt += '</div>';
        objTxt += '  </td></tr>';
		objTxt += '  </table>';
	document.getElementById(baseId).innerHTML = objTxt;	  
    var objChan = {
	           name: baseId,
               selected: sel,
			   unit: "V",
			   offset: 0,
			   range: 1,
			   offsetB: 0,  // Backup offset
			   rangeB: 1,   // Backup range if switched to code
			   factor: 1,
			   offScale: 0,
			   min: 0,
			   max: 0,
			   amplitude: 0,
			   average: 0,
			   frequency: 0,
			   period: 0
              } 
	channels.push(objChan);
	// populate select lists
	var list1 = "";
    for (var i = 0; i < voltRange.length; i++) {
         list1 +='<option value="' + voltRange[i] + '">' + voltRange[i] + '</option>';
    }			 
    document.getElementById("off" + baseId + "ValS").innerHTML = list1;	  
	list1 = "";
    for (var i = 0; i < voltDivRange.length; i++) {
         list1 +='<option value="' + voltDivRange[i] + '">' + voltDivRange[i] + '</option>';
    }			 
    document.getElementById("range" + baseId + "ValS").innerHTML = list1;	  
}		  

// for time id= pos base baseId: Time, range timeRange, timeBaseRange
function addSelectList(id, range, unit) {
	var list1 = "";
    for (var i = 0; i < range.length; i++) {
         list1 +='<option value="' + range[i] + '">' + range[i] + '</option>';
    }			 
    document.getElementById(id + "ValS").innerHTML = list1;	  
}

function addTimeList(){
  addSelectList("pos",timeRange,"s");
  addSelectList("base",timeBaseRange,"s/div");
}

window.addEventListener("load",addTimeList());

function confOsc() {
          var cmdO = "O";
		  // alert(document.getElementById("dataMax").value);
		  dataMax = parseInt(document.getElementById("dataMax").value); // 512: 0200
		  cmdO += decToHex(dataMax,4);           // Block size first
		  timeBase = Math.round(unitToValue(document.getElementById("baseVal").value)/200E-6);
		  cmdO += decToHex((timeBase + 1),4);   // Sampling next FPGA 0 and 1 same! 
		  // update command field
		  document.getElementById("cmdTxt").value = cmdO;
		  sendCmdC();                           // send OSC configuration  
}

function updateOSC(){
	   // update value field
       updateChanFields();
	   updatePlot();
       confOsc();	   
}

function readCRX(key,id,unit) {
	if (!key) {	key = event; key.which = key.keyCode; }
	if (key.which == 13) { 
       updateOSC();
 	}
}

// Claculate min, max, amplitude, average, frequency and period for channels. 
function chanStats() {
  for (var i = 0; i < channels.length; i++) { // all channels
     var min;
	 if (currUnit == 0) min = 1.0 * dataOSC3[i*dataMax/2];
	 else min = dataOSC2[i*dataMax/2];
     var max = min;
	 var avg = min;
     for (var i1 = 1; i1 < dataMax/2; i1++) {
       var point;
	   if (currUnit == 0) point = 1.0 * dataOSC3[i*dataMax/2 + i1];
       else point = dataOSC2[i*dataMax/2 + i1];	   
	   if ( point < min) min = point; 
	   if ( point > max) max = point; 
	   avg = avg + point;
	   // if (isNaN(point)) alert(i1 +" , " + currUnit + " , " + dataOSC3[i*dataMax/2 + i1] + " , " + dataMax);
     }
	 channels[i].min = min;
	 channels[i].max = max;
 	 avg = avg / dataMax * 2;
	 channels[i].average = avg;
     channels[i].amplitude = (max - min)/2;
	 // period and frequency
	 var t = new Array;
	 for (var i1 = 1; i1 < dataMax/2; i1++) {
       var point1;
	   if (currUnit == 0) point1 = 1.0 * dataOSC3[i*dataMax/2 + i1];
       else point1 = dataOSC2[i*dataMax/2 + i1]; 	   
	   var point2;
	   if (currUnit == 0) point2 = 1.0 * dataOSC3[i*dataMax/2 + i1 - 1];
       else point2 = dataOSC2[i*dataMax/2 + i1 - 1]; 	   
	   var point3 = point1;
	   if (point1 > point2) { point1 = point2; point2 = point3; }
       if ((point1 <= avg) && (point2 >= avg)) {
	      t.push(i1);
       }	   
     }
	 // Differences between t(i) half period
	 var tx = new Array;
	 for (var i1 = 1; i1 < t.length; i1++) {
	    tx.push(t[i1]-t[i1-1]); 
	 }
	 var periodAvg = 0;
	 for (var i1 = 1; i1 < tx.length; i1++) {
	    periodAvg += (t[i1]-t[i1-1]);  
	 }
	 if (currUnit == 0) periodAvg = periodAvg / (tx.length-1) * (1.0 * dataOSC3[1] - 1.0 * dataOSC3[0]) * 2;
	 else periodAvg = periodAvg / (tx.length-1) * (dataOSC2[1] - dataOSC2[0]) * 2;
	 channels[i].period = periodAvg;
	 channels[i].frequency = 1/periodAvg;
  }
  var chanTxt = "Measurement <br>\n<table>";
  for (var i = 1; i < channels.length; i++) { // all channels
   if  (channels[i].selected == 1) {
    var xUnit = channels[i].unit;
	var tUnit ="s"; 
	var fUnit="Hz";
	if (currUnit == 0) { xUnit = ""; tUnit=""; fUnit="";}
    chanTxt += "<tr><td class='bo" + i +"'>"; 
	chanTxt += channels[i].name + " Min: " + valueToUnit(channels[i].min)  + xUnit + "<br>"
    chanTxt += channels[i].name + " Max: " + valueToUnit(channels[i].max) + xUnit + "<br>"
    chanTxt += channels[i].name + " Avg: " + valueToUnit(channels[i].average) + xUnit + "<br>"
    chanTxt += channels[i].name + " Amp: " + valueToUnit(channels[i].amplitude) + xUnit + "<br>"
    chanTxt += channels[i].name + " T: " + valueToUnit(channels[i].period) + tUnit +" <br>"
  	chanTxt += channels[i].name + " f: " + valueToUnit(channels[i].frequency) + fUnit + " <br>"
	chanTxt += "</td></tr>";
   }	
  }
  chanTxt += "</table>";
  document.getElementById("measureOSC").innerHTML = chanTxt;
}

function changeUnitX(id,unit) {
  for (var i=0; i < channels.length; i++) {
     if (channels[i].name == id) {
	    channels[i].unit = unit;
		// ToDo: change offset, range list !!
	 }
  }
}

function toggleCheck(id, index){
  var display = document.getElementById("tab"+id).style.display;
  if (display == "block") { 
    document.getElementById("tab"+id).style.display = "none";
    channels[index].selected = 0;
  } else {
    document.getElementById("tab"+id).style.display = "block";
    channels[index].selected = 1;
  }
  updatePlot();
  chanStats()
}

// createChannel("Time","checked",1,0)
var objChan = { name: "time", selected: 1, unit: "s", offset: 0, range: 0.3E-3, offsetB: 0, rangeB: 0.3E-3, factor : 1, offScale: 0 } 
channels.push(objChan);

createChannel("AWG1", "checked",1,0);
createChannel("C1", "checked",2,0);
createChannel("C2", "checked",3,0);
createChannel("C3", "checked",4,0);
createChannel("C4", "checked",5,0);
// createChannel("M1", "",6);
var cList = ["Time","AWG1","C1","C2","C3","C4"];

function updateChanFields() {
  // Time
  channels[0].offset = unitToValue(document.getElementById("posVal").value);
  channels[0].range = unitToValue(document.getElementById("baseVal").value);
  for (var i = 1; i < channels.length; i++) { // no M1 therefore -1 
    channels[i].offset = unitToValue(document.getElementById("off" + cList[i] + "Val").value);
	channels[i].range = unitToValue(document.getElementById("range" + cList[i] + "Val").value);
  }
}

var colorstr = ['#0000ff','#00a000','#ff0000','#ff00ff','#007070','#700070','#ffff00','#00ffff']

function drawGrid(id) {
   var canv_obj=document.getElementById(id);
   
   if (!canv_obj) { alert('Error: I cannot find the canvas element!'); return; }
   if (!canv_obj.getContext) {alert('Error: no canvas.getContext!');return;}
    // Get the 2D canvas context.
   var chart_context = canv_obj.getContext('2d');
   if (!chart_context) { alert('Error: failed to getContext!'); return; }
   chart_context.clearRect(0,0,canv_obj.width,canv_obj.height);
   // Grid
   // 20% are for labels
   var xll = 0.18 * canv_obj.width;
   var xur = (1 -0.18) * canv_obj.width;
   var yll = 0.1 * canv_obj.height;
   var yur = (1 - 0.1)*canv_obj.height;
   chart_context.strokeStyle = "#000000"; // black
   chart_context.beginPath();
   chart_context.rect(xll,yll,xur-xll,yur-yll);
   chart_context.stroke();
   var xstep = Math.round((xur - xll)/10);
   var ystep = Math.round((yur - yll)/10);
   chart_context.lineWidth = 1;
   chart_context.setLineDash([1, 1]);  // dashes are 5px and spaces are 3px
   for (var i = 1; i < 10; i++){  // 10 horizontal
      chart_context.beginPath();
      chart_context.moveTo(xll, yll + i * ystep);
      chart_context.lineTo(xur, yll + i * ystep);
      chart_context.stroke();     
   }   
   for (var i = 1; i < 10; i++){  // 10 horizontal
      chart_context.beginPath();
      chart_context.moveTo(xll + i * xstep, yll);
      chart_context.lineTo(xll + i * xstep, yur);
      chart_context.stroke();     
   }   
   // small marks
    chart_context.setLineDash([]);
   for (var i = 1; i < 100; i++){  // 10 horizontal
      chart_context.beginPath();
      chart_context.moveTo(xll, Math.round((yur - yll)/100 * i + yll));
      chart_context.lineTo(xll + 4, Math.round((yur -yll)/100 * i + yll));
      chart_context.stroke();     
    }      
}

window.addEventListener("load",drawGrid('OSC'));
window.addEventListener("load",drawGrid('fftChart'));

//  
 var currCon = 0;      // current Position of acquisition there the curve starts and ends
 var currUnit = 1;     // Unit voltage or code
 var dataMax = 32*1024;
 var dataOSC1 =[];    // all sorted data
 var dataOSC2 =[];    // final oscilloscope data voltage extracted with trigger 
 var dataOSC3 =[];    // final oscilloscope data code extracted with trigger 
 var xAxisIndex = 0;
 var activeIndex = 1;
 
var mouseStartX = 0;
var mouseStartY = 0;
var mouseCurrX = 0;
var mouseCurrY = 0;
var offsetStart;
var widthX, heightY;
var lines = new Array("pos","offAWG1","offC1","offC2","offC3","offC4","offM1");
var sprites = new Array();  // trigger pos, level, active curve 0, x1, x2 cursor, y1,y2 cursor
// each sprite has: lower left, upper right position; curve color;  type x,x2,y1,y2,filled triangle right, left top, bottom TR,TL,TT, TB
// each sprite has a callback fnction

// Trigger triangle: source, level -> position, color?

function listenCanvas(event) { // event listener for canvas How to add?
      var canv_obj=document.getElementById("OSC");
      var rect = canv_obj.getBoundingClientRect();
      // mouse and touchscreen
      if (mouseX == 1) {   // x - axis right left canvas area? 
        mouseCurrX = Math.round(event.clientX - rect.left);
        mouseCurrY = Math.round(event.clientY - rect.top);
	    channels[xAxisIndex].offset = offsetStart - Math.trunc((mouseCurrX - mouseStartX) / widthX * 100)/10 * channels[xAxisIndex].range;
        document.getElementById("mouse").innerHTML = "Move " + mouseCurrX + "," + mouseCurrY + "," + mouseX;		
	    updatePlot();
		document.getElementById(lines[xAxisIndex]+"Val").value = valueToUnit(channels[xAxisIndex].offset) + channels[xAxisIndex].unit;
		// update range entry!!
      } else if 	(mouseX == 2) { // y axis up down canvas area?
        mouseCurrX = Math.round(event.clientX - rect.left);
        mouseCurrY = Math.round(event.clientY - rect.top);
	    channels[activeIndex].offset = offsetStart - Math.trunc((mouseCurrY - mouseStartY) / heightY * 100) / 10 * channels[activeIndex].range;
        document.getElementById("mouse").innerHTML = "Move " + mouseCurrX + "," + mouseCurrY + "," + mouseX;		
	    updatePlot();
		document.getElementById(lines[activeIndex]+"Val").value = valueToUnit(channels[activeIndex].offset) + channels[activeIndex].unit;
      }
      
      // x1, x2 cursor vertical column canvas area?
      // y1, y2 cursor row canvas area?
      // marker for channels and trigger canvas area?
}

function addCanvasEvent(){
   var canv_obj=document.getElementById("OSC");
   var xll=0.18*canv_obj.width;
   var xur= (0.18+perSizeX)*canv_obj.width;
   widthX = xur - xll;
   var yll=0.1*canv_obj.height;
   var yur=(0.1+perSizeY)*canv_obj.height;
   heightY = yur - yll;
   var xb = canv_obj.width*0.05;
   var yb = canv_obj.height*0.05;
	
   canv_obj.addEventListener('mouseup', function(event){ mouseX = 0;}, false);  // attach event listener to canvas
   canv_obj.addEventListener('mousedown', function(event){ 
        var canv_obj=document.getElementById("OSC");
		var rect = canv_obj.getBoundingClientRect();
		mouseStartX = Math.round(event.clientX - rect.left);
		mouseStartY = Math.round(event.clientY - rect.top);
		// x-axis offset
		if   ((mouseStartX < xur) && (mouseStartX > xll)
          && (mouseStartY < yur + yb) && (mouseStartY > yur)) {
          mouseX = 1;
          offsetStart = channels[xAxisIndex].offset;		  
		} else 
		// y-axis
		if  ((mouseStartX < xll) && (mouseStartX > xll - xb)
          && (mouseStartY < yur) && (mouseStartY > yll)) {
          mouseX = 2; 
          offsetStart = channels[activeIndex].offset;		  
		} 		
        // x1,x2,y1,y2 cursor
        // awg1, c1, c2,c3,c4, xaxis, level triangle 
        document.getElementById("mouse").innerHTML = "Down " + mouseStartX + "," + mouseStartY + "," + mouseX;		
	  }, false
   );  // attach event listener to canvas
   canv_obj.addEventListener('mousemove', listenCanvas, false);  // attach event listener to canvas
   // touchstart, touchmove, touchend   
   // alert("Events registered");
}

window.addEventListener("load",addCanvasEvent());

function activeChan(x) {
  activeIndex = x;
  if (channels[x].selected == 0) { channels[x].selected = 1; } // make active
  updatePlot();
}

function changeXAxis() {
   xAxisIndex = document.getElementById("xyAxis").value; 
   // if (channels[xAxisIndex].selected == 0) { channels[xAxisIndex].selected = 1; } // make active
   updatePlot();
}

function updatePlot(){
   if (currUnit == 0) {  // code
      ScatterPlotO("OSC","Oszilloskop",dataOSC3,dataMax/2,
		                     "time","linO","Minmax",
			                 "Amplitude","linO","auto","Grid",
							 xAxisIndex, activeIndex, channels);
   } else {  // voltage
      ScatterPlotO("OSC","Oszilloskop",dataOSC2,dataMax/2,
		                     "time","linO","Minmax",
			                 "Amplitude","linO","auto","Grid",
							 xAxisIndex, activeIndex, channels);
   }
}

function saveData() {
    var tabTxt ="<span style='background-color:#cce6ff;' onclick='document.getElementById(" + '"dataXY"' + ').style.display = ' + '"none";' + "'> Hide </span><br> <table>";
    var dataMax2= dataMax/2;
    // check for active channels
	var cAWG1 = document.getElementById("cAWG1").checked;
	var cC1 = document.getElementById("cC1").checked;
	var cC2 = document.getElementById("cC2").checked;
	var cC3 = document.getElementById("cC3").checked;
	var cC4 = document.getElementById("cC4").checked;
    // Lables
	   tabTxt += "<tr>";
	   tabTxt += "<td> time / s </td>"; 
	   if (cAWG1) { tabTxt += "<td> AWG1 / V</td>"; }
	   if (cC1) { tabTxt += "<td> OSC1 / V</td>"; }
	   if (cC2) { tabTxt += "<td> OSC2 / V</td>"; }
	   if (cC3) { tabTxt += "<td> OSC3 / V</td>"; }
	   if (cC4) { tabTxt += "<td> OSC4 / V</td>"; }
	   tabTxt += "<td> time code</td>"; 
	   if (cAWG1) { tabTxt += "<td> AWG1 code </td>"; }
	   if (cC1) { tabTxt += "<td> OSC1 code</td>"; }
	   if (cC2) { tabTxt += "<td> OSC2 code</td>"; }
	   if (cC3) { tabTxt += "<td> OSC3 code</td>"; }
	   if (cC4) { tabTxt += "<td> OSC4 code</td>"; }
	   tabTxt += "</tr>"; 
    // values
	for (var i = 0; i < dataMax/2; i++) {
	   tabTxt += "<tr>";
	   tabTxt += "<td>" + dataOSC2[i].toPrecision(6) + "</td>"; 
	   if (cAWG1) { tabTxt += "<td>" + dataOSC2[i + dataMax2].toPrecision(6) + "</td>"; }
	   if (cC1) { tabTxt += "<td>" + dataOSC2[i + 2 * dataMax2].toPrecision(6) + "</td>"; }
	   if (cC2) { tabTxt += "<td>" + dataOSC2[i + 3 * dataMax2].toPrecision(6) + "</td>"; }
	   if (cC3) { tabTxt += "<td>" + dataOSC2[i + 4 * dataMax2].toPrecision(6) + "</td>"; }
	   if (cC4) { tabTxt += "<td>" + dataOSC2[i + 5 * dataMax2].toPrecision(6) + "</td>"; }
	   tabTxt += "<td>" + dataOSC3[i] + "</td>"; 
	   if (cAWG1) { tabTxt += "<td>" + dataOSC3[i + dataMax2] + "</td>"; }
	   if (cC1) { tabTxt += "<td>" + dataOSC3[i + 2 * dataMax2] + "</td>"; }
	   if (cC2) { tabTxt += "<td>" + dataOSC3[i + 3 * dataMax2] + "</td>"; }
	   if (cC3) { tabTxt += "<td>" + dataOSC3[i + 4 * dataMax2] + "</td>"; }
	   if (cC4) { tabTxt += "<td>" + dataOSC3[i + 5 * dataMax2] + "</td>"; }
	   tabTxt += "</tr>"; 
	}
	   tabTxt += "</table>"; 
	document.getElementById("dataXY").innerHTML = tabTxt; 
    document.getElementById("dataXY").style.display = "block";
}

var awgData = new Array();

function generateData() {
    dataMax = parseInt(document.getElementById("dataMax").value); // 512: 0200
    var dataMax2 = dataMax/2;
    genAWGData();
	
    var factor = 1/(4*16*1024-1); // 1 V range XADC, 64k range
    var offset = 0;
    var timeSampling = unitToValue(document.getElementById("timeSampling").innerHTML);
    var timestep = timeSampling * (timeBase + 0);     // XADC 10ns * 8 * 104 cycles conversion +1?
    var dataMax2 = Math.round(dataMax/2);
    for (var i = 0; i < dataMax2; i++) {
       // data OSC2 real voltage values
       // dataOSC2[i] = (i - dataMax/4) / 1E6 * 8 ; // maximum acquistion rate trigger center
       dataOSC2[i] = (i - dataMax/4) * timestep ; // maximum acquistion rate trigger center
       dataOSC2[i + dataMax2] = awgData[i] / 64 / 64 / 256 * 3.3;
       dataOSC2[i + 2 * dataMax2] = 3.3 * (1+Math.sin(i*2*Math.PI/dataMax2));
       dataOSC2[i + 3 * dataMax2] = 1.7 * Math.round((1+Math.sin(i*2*Math.PI/dataMax2)) * 128 ) / 128 ;
       dataOSC2[i + 4 * dataMax2] = 1.0 * Math.round((1+Math.sin(5*i*2*Math.PI/dataMax2)) * 2048) / 2048;
       dataOSC2[i + 5 * dataMax2] = 0.5 * Math.round((1+Math.sin(3*i*2*Math.PI/dataMax2)) * 1024 *1024) / 1024/1024;
	   // data OSC3 code values
	   dataOSC3[i] = i;
       dataOSC3[i + dataMax2] = awgData[i];
       dataOSC3[i + 2 * dataMax2] = Math.round((1+Math.sin(i*2*Math.PI/dataMax2))*64);
       dataOSC3[i + 3 * dataMax2] = Math.round((1+Math.sin(i*2*Math.PI/dataMax2)) * 128 );
       dataOSC3[i + 4 * dataMax2] = Math.round((1+Math.sin(5*i*2*Math.PI/dataMax2)) * 2048);
       dataOSC3[i + 5 * dataMax2] = Math.round((1+Math.sin(3*i*2*Math.PI/dataMax2)) * 64 *1024);
    }
    updatePlot();
	let now = new Date();
    let nowTxt = now.getFullYear() + "/" + (now.getMonth()+1)
               + "/" + now.getDate() + " " + now.getHours()
	     	   + ":" + now.getMinutes() + ":" + now.getSeconds()+ "." + now.getMilliseconds();			
				// 1 Msps 8 samples per point 1E6/8						
	document.getElementById("statusOSC").innerHTML = "Data generated at " + nowTxt + " " + dataMax2 
				   + " samples" ;
    chanStats();
	// generateFFT();
}

//-------------------------------------------------------------------------
//   Simulate AWG
//-------------------------------------------------------------------------

function genAWGData() {
  dataMax = parseInt(document.getElementById("dataMax").value); // 512: 0200
  var dataMax2 = dataMax/2;
  // var timeSampling = unitToValue(document.getElementById("timeSampling").innerHTML);
  // var timestep = timeSampling * (timeBase + 1);     // XADC 10ns * 8 * 104 cycles conversion
				 
  var cmd =	document.getElementById("cmd").innerHTML;
  // triangle or sine
  awgData = [];
  if (cmd[0] == "T" ) { // triangle
    var start = hexToDec(cmd.substring(1,5));  // 16 Bit
	var stop = hexToDec(cmd.substring(5,9));   // 16 Bit
	var step = hexToDec(cmd.substring(9,13));   // 16 Bit
	var repeat = hexToDec(cmd.substring(13,21)); // 32 Bit
	if (repeat < 1) { repeat = 1; }
//	alert(start + "," + step + "," + stop + "," + repeat);
	// T26C9745C4D930000C350
	//  starstopstep
	// 9929,19859,29788,50000
    var valAWG = start;
	var edge = 1;  // rising 1 falling -1
	// 820 = 1/(1MSps/8 (fADC))/10ns (fFPGA fCalc)
    // Number of steps: dataMax2 * timeBase * 820
	var sampleIndex = 0;
	for (var i = 0; i < dataMax2 * timeBase * 820; i++) {
      if ( i % repeat == 0 ) { // enable in FPGA
        valAWG = valAWG + step * edge;                 // operating on 32 BIt values??
        if  ((edge > 0) & (valAWG > stop)) { //rising
		   valAWG = stop - (valAWG - stop); 
		   edge = -1;
        } else 
	    if ((edge < 0) & (valAWG < start)) { // falling		 
		   valAWG = start + (start - valAWG); 
		   edge = 1;
        }	
	  }
      if (i % (820 * timeBase) == 0 ) {  // save sampled data
	      awgData[sampleIndex] = valAWG * 32;
		  sampleIndex ++;
      }	  
	}	
  } else if (cmd[0] == "S" ) {  // sine 32 Bit calculation
    var step = timeBase * hexToDec(cmd.substring(1,9)) * 256;      // angle for +- 1ms, 512 samples 
    var amplitude = hexToDec(cmd.substring(9,17));  
	var offset = hexToDec(cmd.substring(17,25));
	// alert(cmd + "," + step + "," + amplitude + "," + offset + "," + cmd.substring(17,26));
    var scaleMax = 64 * 1024;  // resolution
	var dRe = Math.cos(step/(64*64*1024*1024) * 2 * Math.PI ) ;
	var dIm  = Math.sin(step/(64*64*1024*1024) * 2 * Math.PI );
	var xRe = amplitude;
	var xIm = 0;
	var xRe1;
	var xIm1;
	for (var i = 0; i < dataMax2; i++) {
        awgData [i] = Math.trunc(xRe / 1024 / 2 + offset / 1024 / 2);
   	    xRe1 = Math.trunc( (xRe * dRe) * scaleMax  ) / scaleMax // next step calculation
	         - Math.trunc( (xIm * dIm) * scaleMax  ) / scaleMax; // next step calculation
		xIm1 = Math.trunc( (xRe * dIm ) * scaleMax  ) / scaleMax //  rounded by scaleMax
		     + Math.trunc( (xIm * dRe) * scaleMax  ) / scaleMax; //  rounded by scaleMax
		xRe = xRe1; xIm = xIm1;                                              // update value
	}
  } else {  // ramp
	for (var i = 0; i < dataMax2; i++) {
        awgData [i] = i * 1024;
	}
  }  
}

// changes between voltage and code
// 

function changeUnit() {
  // set currUnit
  currUnit = document.getElementById("currUnit").value;
  if (currUnit == 1) {  // voltage, time 
    // set time 
		addSelectList("pos", timeRange, "s");
		addSelectList("base", timeBaseRange, "s");
	    // all channels restore rangeVal and offVal 
		document.getElementById("posVal").value = channels[0].offsetB;
		document.getElementById("baseVal").value = channels[0].rangeB;
		for (var j = 1; j < channels.length; j++) {
		    addSelectList("range" + channels[j].name, voltRange, "V");
		    addSelectList("off" + channels[j].name, voltRange, "V");
			channels[j].range = channels[j].rangeB;                   // get original range, offset from backup B
			channels[j].offset = channels[j].offsetB;
			document.getElementById("range" + channels[j].name +"Val").value = channels[j].range + " V";
			document.getElementById("off" + channels[j].name +"Val").value = channels[j].offset + " V";
		}
  } else {   // activate Code 
	// set time
		addSelectList("pos", codePos, "");
		addSelectList("base", codeRange, "");
	    // all channels restore rangeVal and offVal 
		document.getElementById("posVal").value = "-" + dataMax/4;
		document.getElementById("baseVal").value = dataMax/16;
		for (var j = 1; j < channels.length; j++) {
		    addSelectList("range" + channels[j].name, codeRange, "");
		    addSelectList("off" + channels[j].name, codePos, "");
			channels[j].rangeB = channels[j].range;
			channels[j].offsetB = channels[j].offset;
			channels[j].range = 512;
			channels[j].offset = -2048;
			document.getElementById("range" + channels[j].name +"Val").value = channels[j].range;
			document.getElementById("off" + channels[j].name +"Val").value = channels[j].offset;
		}
  }     
  // update
  chanStats()
  updateOSC();
}

//----------------------------------------------------------------------------------//
//-------------------- FFT ---------------------------------------------------------//
// based on ADCharacteristic.html --------------------------------------------------//
//----------------------------------------------------------------------------------//
	    function nextPwrOf2(n) {
         var m = -1;
		 var two = 1;
         for (m = 2; m < 16; m++) {
           two = two * 2;
		   if (n < two) return two/2;
		 }
         return -1;
        }

	  function nutall(nPair) { // nutall window
	  var s = new Array();
	  var a0 = 0.3635819;
	  var a1 = 0.4891775;
	  var a2 = 0.1365995;
	  var a3 = 0.0106411;
	  for (var i = 0; i < nPair; i++) {
	     s[i] = a0 - a1 * Math.cos(2*Math.PI*i/nPair) 
		      + a2 * Math.cos(4*Math.PI*i/nPair)
              - a3 * Math.cos(6*Math.PI*i/nPair);
	  }
	  return s;
	  }
	  
      function blackman(nPair) { // blackman window
	  var s = new Array();
	  var a0 = 0.35875;
	  var a1 = 0.48829;
	  var a2 = 0.14128;
	  var a3 = 0.01168;
	  for (var i = 0; i < nPair; i++) {
	     s[i] = a0 - a1 * Math.cos(2*Math.PI*i/(nPair-1)) 
		      + a2 * Math.cos(4*Math.PI*i/(nPair-1))
              - a3 * Math.cos(6*Math.PI*i/(nPair-1));
	  }
	  return s;
	  }

      function hamming(nPair) {
	  var s = new Array();
	  for (var i = 0; i < nPair; i++) {
	     s[i] = 0.54 
		      + 0.46 * Math.cos(2 * Math.PI * (i -nPair / 2 )/ nPair);
	  }
	  return s;
	  }

function calcHarmonics() {
   // which channel
   var actChan = document.getElementById("fftSrc").value;   
   var gr1 = Math.round(nPair / 2) - 1;
   var betragA = [];
   // transfer data to FFT array
    // Calculate signal to noise for first 10 peaks
	// sort Betrag ascending and find signal (largest betrag)
   	var j = parseInt(actChan);   // activeIndex -1 one list only
	var sig = 0;
	var signal = betrag[0 + gr1 * j];
	for(var i = 0; i < gr1; i++)  // transfer to object array
      {
        var timeSampling = unitToValue(document.getElementById("timeSampling").innerHTML);
	    var timestep = timeSampling * (timeBase + 1);     // XADC 10ns * 8 * 104 cycles conversion
        if (currUnit == 0) timestep = 1 / nPair;
	    var objx = {
		             key: betrag[i + gr1 * j], // square of magnitude
					 index: i,
		             freq: (i + 1) / timestep / nPair       // scaled with acquistion time 8 cycle2 1MSps, 256 samples
		};
		if (objx.key > signal) { 
		    sig = objx.index;
			signal = objx.key;
		}
		betragA.push(objx);
      }
	   
	   betragA.sort(function(a,b){ return b.key - a.key});
	   
	   var snrText = "";
	   var noiseA = 0;
	   var maxLength = 10; 
	   for(i = maxLength + 1; i < gr1; i++) // calculate remaining noise without signal
       {
	     if (betragA[i].index != sig) { // not signal
	        noiseA += betragA[i].key; // sum of squares total noise of rest
	     }		
	   }
	   var totalNoise = Math.round(20 * Math.log(Math.sqrt(noiseA))/Math.LN10 * 100)/100;
	   for(i = 0; i < maxLength + 1; i++)
       {
	     snrText = "<tr><td class='bo'>" + (betragA[maxLength - i].index + 1) +"</td><td class='bo'>" 
		           + valueToUnit(betragA[maxLength - i].freq) + "</td><td class='bo'>" // frequency 
		           + Math.round(20 * Math.log(Math.sqrt(betragA[maxLength - i].key))/Math.LN10*100)/100 + "</td><td class='bo'>" // signal
		           + Math.round(20 * Math.log(Math.sqrt(noiseA))/Math.LN10 * 100)/100
				   + "</td></tr>" + snrText;
	     noiseA += betragA[maxLength - i].key; // sum of squares				   
	   }
	   var unitX= "in Hz";
	   if (currUnit == 0) unitX = "";
	   snrText = "<table><tr><td>Magnitude List Channel: </td><td class='bo" + actChan + "'>" + cList[actChan] + "</td></tr></table><br>" +
	             "<table border='1'>" +
	             "<tr><td class='bo'>" + cList[actChan] + "<br>Index</td><td class='bo'>f " + unitX +"</td>" +
	             "<td class='bo'> signal<br> magnitude<br> dB</td>" +
	             "<td class='bo'> Total<br> noise<br> magnitude<br> dB </td></tr>"+ snrText + "</table>";
       document.getElementById('fftList').innerHTML = snrText;
}

   var nPair = 16 * 4 * 256; // 16k samples
   var betrag =[];

function generateFFT() {
   // which channel
   var actChan = document.getElementById("fftSrc").value;
   var fftPts = parseInt(document.getElementById("fftPts").value);
   
   // transfer data to FFT array
   var ind = +1; // +1 forward fft -1 reverse fft
   var aR = [];  // real values 
   var aI = [];  // new Array() imaginary values
   var betragdB = [];
   var betragA = [];
   var channelsA =[];
   var maxG = 0;
   var minG = 1;

   currUnit = document.getElementById("currUnit").value;
   nPair = dataMax / 2 / fftPts;  // Arduino otherwise /2
   // alert( currUnit + "," + nPair); // 16384
   
   for (var j = 0; j < channels.length; j++) { // all channels
	 channelsA[j] = Object.assign({}, channels[j]);
   }
   // start FFT
  for (var j = 0; j < 5; j++) { // all channels
   
   for (var i = 0; i < nPair; i++) {
      // aR[i] = dataOSC2[i + actChan * nPair];
	  if (currUnit == 1) {  // voltage, time
	     aR[i] = dataOSC2[i * fftPts + (j + 1) * nPair * fftPts];
	  } else {              // code
	     aR[i] = 1E-6 * dataOSC3[i *fftPts + (j + 1) * nPair * fftPts];
	  }
	  aI[i] = 0;
   }
   
   fft(ind, nPair, aR, aI);  //  FFT
  
   // Calculate Magnitude
   var gr1 = Math.round(nPair / 2) - 1;
   for(var i = 0; i < gr1; i++) {   // all buckets, no DC
     var timeSampling = unitToValue(document.getElementById("timeSampling").innerHTML);
	 var timestep = timeSampling * (timeBase + 1) * fftPts;     // XADC 10ns * 8 * 104 cycles conversion
	 if (currUnit == 0) timestep = 1 / nPair;
	 //	 var timestep = 8.32E-6;
	 betragdB[i] = (i + 1) / timestep / nPair;           // scaled with acquistion time 8 cycle2 1MSps, 256 samples
	 betrag[i] = (i + 1) / timestep / nPair;
	 if ( isNaN(aR[i + 1]) || isNaN(aR[i + 1]) ) alert(i + "," + aR[i + 1] + "," + aI[i + 1]);  
	 betrag[i + gr1 * (j + 1)] = 2 * (aR[i + 1] * aR[i + 1] + aI[i + 1] * aI[i + 1]);
     // alert(i + "," + gr1 + "," + j + "," + betrag[i + gr1 * (j + 1)]);
   }	 
		
   // fix betrag = 0 for log operation
   var min = betrag[0 + gr1 * (j + 1)];
   var max = betrag[0 + gr1 * (j + 1)];
   for(var i = 1; i < gr1; i++) {   
	 if ((betrag[i + gr1 * (j + 1)] < min) && (betrag[i + gr1 * (j + 1)] > 0)) { // set min
	   min = betrag[i + gr1 * (j + 1)];
	 }
	 if ((betrag[i + gr1 * (j + 1)] > max)) max = betrag[i + gr1 * (j + 1)];   // set max
	 if ((betrag[i + gr1 * (j + 1)] < 0)) alert("negativ");
   }
   // alert(min + "," + (10 * Math.log(min) / Math.LN10));
   // Convert to dB 
   if (min == 0) min = 1E-3; // prevent log(0)
   
   for(var i = 0; i < gr1; i++) {   // all buckets, no DC
     if (betrag[i + gr1 * (j + 1)] == 0) {
		  betragdB[i + gr1 * (j + 1)] = 10 * Math.log(min) / Math.LN10; // 10 because of sqrt;
	 } else { 
		   betragdB[i + gr1 * (j + 1)] = 10 * Math.log(betrag[i + gr1 * (j + 1)]) / Math.LN10; // 10 because of sqrt
	 }
    }
	 
	
	if (channelsA[j].selected == 1) {
	  if (min < minG) { minG = min; }
	  if (max > maxG) { maxG = max; }
	}  
   }
   // set y axis
   maxG = 10 * Math.log(maxG) / Math.LN10;
   minG = 10 * Math.log(minG) / Math.LN10;
   // if (!isFinite(MinG)) { minG = 1E-3;}  
   // scale_lin_max_min (maxG,minG,"auto"); // it is not yet clear what the axis settings are!!
   // alert("Max:" + maxG + ", Min:" + minG + "x");
   maxG = oMax;
   minG = oMin;
   var range = (maxG - minG) / 10;
   range = 20;
   var offset = - (maxG + minG) / 2;
   offset = 90;
   for (var j = 1; j < channelsA.length; j++) { // all channels
    channelsA[j].range = range;
    channelsA[j].offset = offset;
   }

   // alert(0 + "," + 127 + "," + 3 + "," + betrag[0 + 127 * (3 + 1)]);
   // Graphics
   // FFT Chart
	// ScatterPlotO takes range from above   betragdB
	ScatterPlotO("fftChart",((gr1+1) + " points FFT"),betragdB,gr1,
	              "Frequency","log","auto",
				  "Magnitude [dB]","lin","minmax","Fine"  //Grid auto0
				  ,0, activeIndex, channelsA
				 );
				 
	calcHarmonics(); // update List   
}

//----------------------------------------------------------------------------------//
//-------------------- Histogram ---------------------------------------------//
//----------------------------------------------------------------------------------//
var histo = [];

function createBinBox() { 
                 // text            id      list     Unit slider? 
   var codeRangeLim =[];
    for (var j = 0; j < 5; j++) { // all channels
	   codeRangeLim[j] = codeRange[j];
    }
   
   createComboBox("Number of Bins","bins",codeRangeLim,"",3);
}

function selectBinBox() { 
	document.getElementById("binsValS").value = codeRange[3]; 
}

window.addEventListener("load",createBinBox());
window.addEventListener("load",selectBinBox());


function generateHisto(){
    var dataMax2 = Math.round(dataMax/2); // number of points
	var step = [];
    var dataBins = [];
    var channelsA =[];
    var valTable ="<table><tr><td>Channel</td><td>Min</td><td>Bin Step</td><td>Max</td></tr>";
	var nrBins = document.getElementById("binsVal").value;
		
    for (var j = 0; j < channels.length; j++) { // all channels
	   channelsA[j] = Object.assign({}, channels[j]);
    }
	channelsA[0].offset = - (nrBins-1)/2;
	channelsA[0].range = (nrBins-1)/10;
	
	// get number of bins
    // alert(nrBins);
	var unitX = "V";
	if (currUnit == 0) unitX ="";
	for (var i = 1; i < channels.length; i++) {
     step[i] = (channels[i].max - channels[i].min)/(nrBins-1); // if zero all in bin zero
	 if (channels[i].selected == 1) {
	   valTable +="<tr class='bo" + i + "'><td class='bo" + i + "'>" + channels[i].name + "</td><td>" + valueToUnit(channels[i].min) 
	             + unitX + "</td><td>" + valueToUnit(step[i]) + unitX +"</td><td>" + valueToUnit(channels[i].max) + unitX + "</td></tr>"
	 }
	}
	valTable +="</table>";
	document.getElementById("binsTab").innerHTML = valTable;
	for (var i = 0; i < nrBins; i++) { 	// prefill histo
	  dataBins[i] = i;
	  for (var j = 1; j < 6; j++) { 	// all channels
	  	  dataBins[i + j * nrBins] = 0;
	  }	  
	}
	// fill histo
	// alert(dataMax2);
	for (var i = 0; i < dataMax2; i++) {
	  for (var j = 1; j < 6; j++) { 	// all channels
	  	  var index;
		  if (currUnit == 1) {  // voltage, time
             index = Math.round((dataOSC2[i+j*dataMax2] - channels[j].min)/step[j]);
	      } else {              // code
	         index = Math.round((dataOSC3[i+j*dataMax2] - channels[j].min)/step[j]);
	      }
		  if (currUnit == 0) index = Math.round((dataOSC3[i+j*dataMax2] - channels[j].min)/step[j]);
		  dataBins[index + j * nrBins] += 1; // add to bucket
	  }	  
	}
    let now = new Date();
    let nowTxt = now.getFullYear() + "/" + (now.getMonth()+1)
                   + "/" + now.getDate() + " " + now.getHours()
				   + ":" + now.getMinutes() + ":" + now.getSeconds()+ "." + now.getMilliseconds();			
		nowTxt += "Histogram from " + dataMax2 + " points generated at " + nowTxt;

	// generate chart
    ScatterPlotO("histoChart",nowTxt,dataBins,nrBins,
	              "Bins","lin","minmax",
				  "occurence","lin","minmax","Grid"  //Grid
				  ,0, activeIndex, channelsA   // axis proper scaling difficult
				 );
}

window.addEventListener("load",generateData());


//----------------------------------------------------------------------------------//
//-------------------- Ramp Test INL and DNL ---------------------------------------//
//----------------------------------------------------------------------------------//

function ramp() {
    var dataMax2 = Math.round(dataMax/2); // number of points 16k
	var avgVal = [];
	var idealVal =[];
	var dataINL = [];
	var dataDNL = [];
	var LSB =[];
    var nrCodes; // = parseInt(document.getElementById("codesVal").value);  // number of code values
    // alert(nrCodes + "," + document.getElementById("codesVal").value);
    var stepCode = parseInt(document.getElementById("codesStep").value);  // number of code values
	if (stepCode <= 0) { stepCode = 1; }
	var startCode = parseInt(document.getElementById("codesStart").value);  // number of code values
    var endCode = parseInt(document.getElementById("codesEnd").value);  // number of code values
    var rampSrc = parseInt(document.getElementById("rampSrc").value);  // number of code values
	var avgNr =  Math.round(dataMax2 / (endCode - startCode + 1) / 4); // dataMax2 / 256 / 4;  
	var nrError = Math.trunc((endCode - startCode + 1)/stepCode);
    nrCodes = Math.trunc((endCode - startCode) / stepCode) + 1; // for graph bins
	
	/* alert(nrCodes + "," + stepCode + "," + startCode + "," 
	    + endCode + "," +avgNr + "," + nrError);
    */
	
    var channelsA =[];

    for (var j = 0; j < channels.length; j++) { // Copy all channels
	   channelsA[j] = Object.assign({}, channels[j]);
	   channelsA[j].selected = "0";
    }
	channelsA[0].offset = - (nrCodes-1)/2;
	channelsA[0].range = (nrCodes-1)/10;
    channelsA[rampSrc].selected = "1";
    
	
	// make array with average value avgVal	which will be analyzed for INL, DNL
	// fill INL, DNL
	// dataOSC3 first column output code AWG
    for (var j = 0; j < nrCodes; j++) { 	            // set codes (x values) in avgVal
      avgVal[j] = j;
	}
	
    for (var j = rampSrc; j < rampSrc+1; j++) { 	   // channel rampSrc average measurement data to nrCodes
      for (var i = 0; i < nrCodes; i++) {              // number of codes loop  
	    var avgX = 0;
		for (var k = 0; k < avgNr; k++) {              // averaging loop  
           avgX += dataOSC3[(i * stepCode + startCode) * avgNr + j * dataMax2 + k];
	    }	  
        avgVal[nrCodes + i] = avgX / avgNr;            // 
	  }	  
	}
	
	// make array with ideal values
    for (var j = 0; j < nrCodes; j++) { 	            // set codes in avgVal
      idealVal[j] = j;
	}
    for (var j = rampSrc; j < rampSrc + 1; j++) { 	  // channel rampSrc LSB calculation and ideal copy
	  var startVal = avgVal[nrCodes];
	  var endVal = avgVal[2 * nrCodes - 1];
	  var delta = (endVal - startVal) / (nrError-1);
	  LSB[j] = delta;
	  for (var i = 0; i < nrCodes; i++) {              // number of codes loop  
        idealVal[ nrCodes + i] = startVal + delta * i;  // one channel only
	    avgVal[2 * nrCodes + i] = idealVal[nrCodes + i];       // copy ideal to avgVal
	  }	  
	}
    
	// make array with INL, DNL
    for (var j = 0; j < nrCodes; j++) { 	            // set codes in avgVal
      dataINL[j] = j * stepCode + startCode;
      dataDNL[j] = j * stepCode + startCode;
	}
    var inlMin = 0;
    var inlMax = 0;
    var dnlMin = 0;
    var dnlMax = 0;
	var inlTotal = 0;
    for (var j = rampSrc; j < rampSrc+1; j++) { 	// channel rampSrc INL, DNL analysis
      dataINL[nrCodes] = 0; // INL
      dataDNL[nrCodes] = 0; // DNL
	  avgVal[3 * nrCodes] = 0;
	  avgVal[4 * nrCodes] = 0;
	  for (var i = 1; i < nrCodes; i++) {              // number of codes loop  
        var inlX = (avgVal[nrCodes+i] -  idealVal[nrCodes+i])/LSB[j] ;
		var dnlX = (avgVal[nrCodes+i] -  avgVal[nrCodes+i -1] - LSB[j])/LSB[j] ;
		dataINL[nrCodes + i] = inlX; // INL
        dataDNL[nrCodes + i] = dnlX; // DNL
   	    avgVal[3 * nrCodes + i] = inlX;
   	    avgVal[4 * nrCodes + i] = dnlX;
		inlTotal += inlX * inlX; 
		if (inlX > inlMax) inlMax = inlX;
		if (inlX < inlMin) inlMin = inlX;
		if (dnlX > dnlMax) dnlMax = dnlX;
		if (dnlX < dnlMin) dnlMin = dnlX;
	  }	  
	}
	inlTotal = Math.sqrt(inlTotal);
    document.getElementById("inlResult").innerHTML = "INL " + inlMin.toPrecision(3) 
	   + ".." + inlMax.toPrecision(3) + " DNL " + dnlMin.toPrecision(3) + ".." + dnlMax.toPrecision(3)
	   + " INL Total: " + inlTotal;
   
    let now = new Date();
    let nowTxt = now.getFullYear() + "/" + (now.getMonth()+1)
                   + "/" + now.getDate() + " " + now.getHours()
				   + ":" + now.getMinutes() + ":" + now.getSeconds()+ "." + now.getMilliseconds();			
		nowTxt += " INL DNL from " + (dataMax2 / 4) + " points generated from " 
		          + startCode + " up to " + endCode + " in " + stepCode + " steps";

    // alert(activeIndex);
	
	// generate chart
	// avgVal,nrCodes
	// dataINLDNL,nrCodes
    ScatterPlot("inlChart",nowTxt,dataINL,nrCodes,
	              "Code","lin","minmax",
				  "INL","lin","auto","Grid"  //Grid
				//  ,0, activeIndex, channelsA   // axis proper scaling difficult use with  ScatterPlotO only works with one data array per channel
				 );
    ScatterPlot("dnlChart",nowTxt,dataDNL,nrCodes,
	              "Code","lin","minmax",
				  "DNL","lin","auto","Grid"  //Grid
				//  ,0, activeIndex, channelsA   // axis proper scaling difficult use with  ScatterPlotO only works with one data array per channel
				 );

// show data for one channel: code, real, ideal, INL, DNL
    setLegend("Real,Ideal,INL,DNL");
    ScatterPlotX("rampChart",nowTxt,avgVal,nrCodes,
	              "Code","lin","minmax",
				  "Value, INL, DNL","lin","minmax","Grid"  //Grid
				 );
// -------------------------------------------
// Missing binary error list
// Assumption power of 2 values
// -------------------------------------------
// What size power of 2?
// Loop over power of 2
// {   Difference 2^i and 2^i-1 }
// save results in section id="??" 
// button for transfer to Arduino
// option for averaging at arduino??

// make lookup table
// cLook checked
// sort real values and get maximum step maxStep
  var cList = new Array();
  for (var i = 0; i < nrCodes; i++) {              // number of codes loop  
    var curveObj = {
				       code : avgVal[i],
	                   out : avgVal[i + nrCodes]    
				   }				   
    cList.push(curveObj);
  }
  cList.sort(function(a,b) { // sort output values
         if ( a.out < b.out )
             return -1;
         if ( a.out > b.out )
             return 1;
         return 0;
    });
  var maxStep = cList[1].out - cList[0].out;	
  for (var i = 2; i < nrCodes; i++) {              // get maximum step  
    var stepM = cList[i].out - cList[i-1].out;
	if (stepM > maxStep) { maxStep = stepM; }
  }   	
// maximum step = 1.0..1.5 LSB
  var stepScale = parseFloat(document.getElementById("stepScale").value);  // number of code values
    maxStep = stepScale * maxStep;
  if (maxStep == 0 ) { alert("maxStep = 0"); }
  else {
   var maxCodes = (cList[nrCodes - 1].out - cList[0].out) / maxStep;
// Look for suitable values going through sorted array
   var lookupList = [];
   lookupList[0] = cList[0].code;
   var nextVal = cList[0].out + maxStep;
   var indexL = 1;
   lookupList[indexL] = cList[1].code;
   var errorL = Math.abs(cList[1].out - nextVal);
   for (var i = 2; i < nrCodes; i++) {   // get lookup list 
     var errorN = cList[i].out - nextVal;
     if (errorN > 0.5 * maxStep) { // next value
	    indexL = indexL +1;
		nextVal = nextVal + maxStep;
		errorN = cList[i].out - nextVal;
		errorL = Math.abs(errorN);
        lookupList[indexL] = cList[i].code;
     }	 
	 if (Math.abs(errorN) < errorL) {   // absolute error better
        lookupList[indexL] = cList[i].code;
		errorL = Math.abs(errorN);
	 }
   }				
   var rangeN = indexL;   
   for (var i = indexL + 1; i < nrCodes; i++) {   // fill up rest 
      lookupList[i] = cList[nrCodes-1].code;
   }
   var lText = "Min: " + cList[0].out + " Max: " + cList[nrCodes-1].out 
              + " Step: " + maxStep + " New Codes: " + rangeN + "<br>\n";
   lText += "Lookup Table: <br>\n";
   var xText = lText;  
   for (var i = 0; i < 16; i++) {   // fill up rest 
      for (var j = 0; j < 16; j++) {   // fill up rest 
         lText += lookupList[i * 16 + j] + ",";
		 xText += lookupList[i * 16 + j] + ",";
      }
	  lText = lText + "<br>\n";
	  xText = xText +"\n";
   }
   xText = xText.substring(0, xText.length-2);
   document.getElementById("bestL").innerHTML = lText;
   document.getElementById("lookupX").value = xText;
   // calculate new INL, DNL and redo with different maxStep if necessary
  
  }
  
}

//----------------------------------------------------------------------------------//
//-------------------- Lookup Table ---------------------------------------------//
//----------------------------------------------------------------------------------//

function sendLookup() {
 var lookupText = lookupX.value;
 // remove carriage return line break
  document.getElementById("cmd").innerHTML = "t" + lookupText.replace(/(\r\n|\n|\r)/gm,"");
  sendCmd();
}

function myLookup() {
 var seqx = [7,8,11,15];
 var lookupText = "Range: 64<br>\n";
 // remove carriage return line break
  var lSize = 0; 
 for (var j = 0; j < 16 * 4; j++) { //  
   for (var j1 = 0; j1 < 4; j1++) { //
     lSize++;
	 var zz = seqx[j1] + j * 16;
	 if ( zz > 255) zz = 255;
	 lookupText = lookupText + zz + ",";
	 if (lSize % 32 == 0) lookupText = lookupText + "<br>\n";
   }
  }
  document.getElementById("myLookup").innerHTML = lookupText;
}  

function resetLookup() {
  var lookupText;
  lookupX.value = document.getElementById("linearT").innerHTML.replace(/<br>/gm,"");
  lookupText = document.getElementById("linearT").innerHTML.replace(/<br>/gm,"");
 // remove carriage return line break
  document.getElementById("cmd").innerHTML = "t" + lookupText.replace(/(\r\n|\n|\r)/gm,"");
  sendCmd();
}

//----------------------------------------------------------------------------------//
//-------------------- NodeJS commands ---------------------------------------------//
//----------------------------------------------------------------------------------//

var socket = io.connect();
 
var fullDataT = "";
var maxXi = 0; 
 
        socket.on('newData', function (data) {                  // get from server all data
			var dataY = data.value;
			if (dataY[0] == 'f') document.getElementById("dataXYZ").innerHTML = dataY + "<br>";
			document.getElementById("dataX").innerHTML = dataY + "<br>";
            // Example
			// run, index   curve 
			//         type    val    PMOD ADC   val     Pin A1            Pin A2            Pin A3           Pin A4
			// 0, 13755 , Sine = 2810 , ADC(AD2) = 2791 , ADC(OSC1) = 701 , ADC(OSC2) = 702 , ADC(OSC3) = 706 , ADC(OSC4) = 702
            // some channels could be ommitted
            // split line 
			var pairs = dataY.split(",");
			// Fill Oscilloscope array
			//  check first element is a number
            var dataMax2 = Math.round(dataMax/2);
			var indexX = parseInt(pairs[1]);
			
			   document.getElementById("mouse").innerHTML = indexX + "<br>";
			
			if (!isNaN(indexX)) {		
			   if (indexX > maxXi) maxXi = indexX;
               dataOSC2[indexX] = indexX;			
			   // get integers
			   var proc = indexX + ",";
			   for (var jx1 = 2; jx1 < 7; jx1++) { // pairs.length
 			     var valX1 = pairs[jx1].split("=");    
			     dataOSC3[indexX + (jx1 - 1) * dataMax2] = parseInt(valX1[1]); 
				 proc = proc + valX1[1] + ",";
			   }
			   if (oState == "Run") {
                   document.getElementById("mouse").innerHTML = proc + "<br>";
			   }	   
			   // Display takes some time so update only every 100 value
			   // if Run is active
			   if (((indexX + 1) % 1024 == 0) && (oState == "Run")) {
			      updatePlot();
   		          chanStats();

				  let now = new Date();
                  let nowTxt = now.getFullYear() + "/" + (now.getMonth()+1)
                             + "/" + now.getDate() + " " + now.getHours()
					         + ":" + now.getMinutes() + ":" + now.getSeconds()+ "." + now.getMilliseconds();			
				  // 1 Msps 8 samples per point 1E6/8						
				  document.getElementById("statusOSC").innerHTML = nowTxt + " " + dataMax2 + " samples at " 
				     + valueToUnit(1E6/8) + "Hz/" + valueToUnit(8/1E6) + "s " + maxXi;
			   }
            }
            // sine FFT  sine selected , oscilloscope running
			if (((indexX + 1) % (8 * 1024) == 0) && (curveTyp == 1) && (oState == "Run")) {
			   // alert("FFT");
			   generateFFT();
			}
			// ramp DAC INL, DNL
			if (((indexX + 1) % (4 * 1024) == 0) && (oState == "Run")) {
			   // INL, DNL graph
			   ramp();
			}
			// (ramp ADC)
			
        });
        
        function sendCmd()   // filename fName send to server
        {
            var cmd = document.getElementById("cmd").innerHTML ;
			// if (cmd="U") alert("Tx");
            socket.emit('cmd', { value: cmd });
        }
		
        function sendCmdC()   // filename fName send to server
        {
			var cmd = document.getElementById("cmdTxt").value;
			try {
			  socket.emit('cmd', { value: cmd });
			} catch (error) { console.error(error); }
			let now = new Date();
            let nowTxt = now.getFullYear() + "/" + (now.getMonth()+1)
                           + "/" + now.getDate() + " " + now.getHours()
						   + ":" + now.getMinutes() + ":" + now.getSeconds()+ "." + now.getMilliseconds();			
			document.getElementById("lCmd").innerHTML = "Sent command: " + cmd + " at " + nowTxt;
        }

window.addEventListener("load",changeUnit());
window.addEventListener("load",confOsc());
window.addEventListener("load",myLookup());
// window.addEventListener("load",sendCmd());

		// Will pop up regularly
		// socket.on("connect_error", (error) => {
           // ...
		//   alert("connect error");
        // });
	
</script>
	
	
	</body>
	</html>