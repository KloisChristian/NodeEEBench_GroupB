<html lang="en">
  <head>
<meta name="description" content="User interface of EEBench an open source, open access low cost
   oscilloscope and arbitrary waveform generator based on FPGA BASYS3 and nodejs JavaScript" />
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" type="text/css" href="../css/style.css" media="all" />
    <title>Node EEBench</title>
 <style>
.slidecontainer {
  width: 100%;
}

.slider {
  -webkit-appearance: none;
  width: 100%;
  height: 10px;
  background: #d3d3d3;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slider:hover {
  opacity: 1;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 10px;
  height: 20px;
  background: #0067a5;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 10px;
  height: 20px;
  background: #0067a5;
  cursor: pointer;
}

.nobr { white-space: nowrap }

table.bx { border-collapse: collapse; }

table.bo, tr.bo, th.bo, td.bo {  border: 1px solid black; border-collapse: collapse; padding-left: 10px; 
padding-right: 10px;
}

table.bo0, tr.bo0, th.bo0, td.bo0 { border: 3px solid black; border-collapse: collapse;}
table.bo1, tr.bo1, th.bo1, td.bo1 { border: 3px solid #FF8C00; border-collapse: collapse;}
table.bo2, tr.bo2, th.bo2, td.bo2 { border: 3px solid #0000FF; border-collapse: collapse;}
table.bo3, tr.bo3, th.bo3, td.bo3 { border: 3px solid #FF1493; border-collapse: collapse;}
table.bo4, tr.bo4, th.bo4, td.bo4 { border: 3px solid #008000; border-collapse: collapse;}
table.bo5, tr.bo5, th.bo5, td.bo5 { border: 3px solid #FF4500; border-collapse: collapse;}
table.bo6, tr.bo6, th.bo6, td.bo6 { border: 3px solid #4682B4; border-collapse: collapse;}
table.bo7, tr.bo7, th.bo7, td.bo7 { border: 3px solid #DC143C; border-collapse: collapse;}
table.bo8, tr.bo8, th.bo8, td.bo8 { border: 3px solid #ABABAB; border-collapse: collapse;}

table.tb, tr.tb, th.tb, td.tb { border: 3px solid black; background: #ABABAB; border-collapse: collapse;}
table.tbs, tr.tbs, th.tbs, td.tbs { border-top: 3px solid black; border-left: 3px solid black; 
border-right: 3px solid black; background: white; border-collapse: collapse;}
td.tbr:last-child { width:100%; border-bottom: 3px solid black; background: white; border-collapse: collapse;}
td.top {vertical-align: top;}

</style> 
  </head>
  
<!-- load socket.io Google -->
<script src="../node_modules/socket.io/client-dist/socket.io.js"></script>
<!-- load JQuery -->
<SCRIPT SRC="../scripts/jquery.js"> </SCRIPT>
<!-- load Chart module-->
   <script type="text/javascript" src="../Chart_2013_03_11/Chart_basic.js"></script>
<!-- load FFT module-->
  <script type="text/javascript" src="../FFT/dspFFT.js"></script>
  <body>
  <div id="headx" style="display:block">
  <div id="nheader1" style="background-color:#0067a5;color:#FFFFFF" align="right" >
     <a href="http://www.hochschule-kempten.de" style="color:#FFFFFF"> Hochschule Kempten &nbsp; &nbsp; &nbsp; </a>
  </div>
  <div id="nheader2" style="background-color:#05adb5;color:#FFFFFF" align="right" >
     <a href="http://www.hochschule-kempten.de/about-kempten-university/faculties/electrical-engineering.html?L=1" style="color:#FFFFFF">
	 Fakult&auml;t Elektrotechnik &nbsp; &nbsp; &nbsp;
  </div>
  <div id="nheader3" style="background-color:#f18700;color:#FFFFFF" align="right">
     <a href="Elektronik.html" style="background-color:#f18700;color:#FFFFFF"> 
	 Elektronik &nbsp; &nbsp; &nbsp;</a>
    <a href="http://www.hochschule-kempten.de/metanavigation/personen/detailansicht.html?typo3state=persons&lsfid=1000430" style="background-color:#f18700;color:#FFFFFF"> 
	 Fachgebiet Elektronik, Prof. Vollrath &nbsp; &nbsp; &nbsp;</a>
  </div>
  </div>
  <br>

<table class="bx" id="tabs">
<tr><td class="tbs" onclick="tabAct(0)">&nbsp;&nbsp;Configuration&nbsp;&nbsp; </td>
    <td class="tb" onclick="tabAct(1)">&nbsp;&nbsp;AWG1&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(2)">&nbsp;&nbsp;OSC&nbsp;&nbsp;</td>
	<td  class="tb" onclick="tabAct(3)">&nbsp;&nbsp;FFT&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(4)">&nbsp;&nbsp;Histogram&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(5)">&nbsp;&nbsp;Ramp&nbsp;Test&nbsp;INL,&nbsp;DNL&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(6)">&nbsp;&nbsp;Lookup&nbsp;Table&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(7)">&nbsp;&nbsp;Settling&nbsp;Time&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(8)">&nbsp;&nbsp;Power&nbsp;Supply&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(9)">&nbsp;&nbsp;Bodeplot&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(10)">&nbsp;&nbsp;Digital&nbsp;I/O&nbsp;&nbsp;</td>
	<td class="tb" onclick="tabAct(11)">&nbsp;&nbsp;Applications&nbsp;&nbsp;</td>
	<td class="tbr"> &nbsp; &nbsp; </td></tr>
</table>

<!---------------------- Configuration ------------------------------------------->
<div id="tab0" class="tabX" style="display:block">
  <h2> Configuration </h2>
  <br>
  <table>
  <tr>
  <td> System: </td>
    <td>Board:</td>
	<td id="boardT">
	 <select name="board" id="board" onchange="selectBoard()">
      <option value="0"> BASYS 3 </option>
      <option value="1"> Simulation not working yet</option>
      <option value="2"> Arduino MKR Wifi 1010 not working yet</option>
      <option value="3"> Raspberry Pi not working yet</option>
      <option value="4"> Infineon XMC4700 Relax Kit not working yet</option>
      </select>
    </td>
  </tr>
  <tr>
  <td> System: </td>
    <td>Communication:</td>
	<td id="com">Serial over USB (Serial NodeJs, LAN over USB?, WLAN?)</td>
  </tr>
  </table>
  <table>
  <tr>
    <td>OSC1:</td><td> XADC1 (12 Bit, 1 MSps / 8)</td>
    <td>OSC2:</td><td> XADC2 (12 Bit, 1 MSps / 8)</td>
    <td>OSC3:</td><td> XADC3 (12 Bit, 1 MSps / 8)</td>
    <td>OSC4:</td><td> XADC4 (12 Bit, 1 MSps / 8)</td>
  </tr>
  <tr>
    <td colspan="2">OSC Sampling time: </td>
	<td> <input type="text" value="8.32 us" size="7" id="timeSampling" onkeyup="selectBoard()"/> 
    </td>
    <td colspan="2">OSC maximum buffer size: </td>
	<td> <input type="text" value="8192" size="5" id="oBufVal" onkeyup=""/>
    </td>
  </tr>
  <tr>
    <td>AWG1:</td><td> R2R (16 Bit)</td>
    <td>AWG2:</td><td> None</td>
  </tr>
  <tr>
  <td> AWG1: </td>
    <td>Minimum voltage:</td>
	<td id="AWG1MinV"><input type="text" value="0 V" size="5" id="AWG1MinVVal" onkeyup=""/></td>
    <td>Maximum voltage:</td><td id="AWG1MaxV"><input type="text" value="3.3 V" size="5" id="AWG1MaxVVal" onkeyup=""/></td>
    <td>Resolution (Bits):</td><td id="AWG1Res"><input type="text" value="16" size="5" id="AWG1ResVal" onkeyup=""/></td>
  </tr>
  <tr>
  <td colspan="2"> AWG1 sampling time: </td>
  <td id="AWG1ts"><input type="text" value="10 ns" size="5" id="AWG1tsVal" onkeyup=""/></td>
  </tr>
  <tr>
  <td colspan="2"> Lookup buffer size: </td>
  <td id="lBuf"><input type="text" value="8192" size="5" id="lBufVal" onkeyup=""/></td>
  </tr>
  
  <tr>
  <td colspan="7"> 
   <span  id="board0" style="display:block"><img src="../ImagesS/BASYS3_V04_01.png" width="400"></span>
   <span  id="board2" style="display:block"><img src="../ImagesS/Arduino_MKR_WIFI_1010_ADCDAC.png" width="400"></span>
  </td>
  </tr>
  </table>

  <span id="sCmd" onclick="sendCmdC()"><img src="ImagesS/Run.png" width="16"> Send Command  </span>
  <input type="text" value="X" size="40" id="cmdTxt"/>  <br>
  <div id="lCmd">Sent: </div>
  <br>
  <hr>
  <br>
<a href="https://github.com/JVollrath/NodeEEBench" class="blue">Github NodeEeBench</a><br>
<a href="https://personalpages.hs-kempten.de/~vollratj/GET2/EI_Projektpraktikum.html" class="blue">EI Projektpraktikum</a><br>
<a href="https://personalpages.hs-kempten.de/~vollratj/Projekte/2023_ResearchSummary.html" class="blue">Research Summary</a><br>
<a href="../Documentation/Installation.html" class="blue">Installation Notes</a><br>

<h4>Implemented commands with command example values according to (FPGA BASYS 3, Arduino) board:</h4><br>
<table>
<tr><td>"X"</td><td> (length = 1) initialize</td></tr>
<tr><td style="vertical-align:top">"S"</td>
    <td> (length = 25) sine signal, followed by 24-hex numbers: step, amplitude, offset each 32 bit<br>
    <br>
     Example f = 1 kHz, amp = 1 V, offset = 1 V as shown in AWG1: S0000A7C526C9B26C26C9B26C<br>
    <br>
     step = 0000A7C5, amplitude = 26C9B26C, offset = 26C9B26C<br>
    <br>
     Sine for FFT for BASY3:<br>
     FFT looks good for Oscilloscope up to 1 ms/div.<br>
     3 cycles, 1.40851 kHZ, 196608 = 3*64*1024      S000300001364D9361364D936<br>
     11 cycles, 5.16452 kHz, 720896 = 11* 64 *1024            S000B00001364D9361364D936<br>
     101 cycles, 47.419625 kHz, 6619136 = 101 * 64 * 1024	     S006500001364D9361364D936<br>
    </td></tr>
<tr><td style="vertical-align:top">"T"</td>
    <td> (length = 21) triangle signal, followed by 20-hex numbers: start, stop, step (16-bit each), repeat (32 bit)<br>
      <br>
       Example pulse f = 1 kHz, amp = 1 V, offset = 1 V as shown in AWG1: T00004D924D920000C350<br>
      <br>
       start = 0000, stop = 4D92, step = 4D92, repeat = 0000C350<br> 
      <br>
       Example triangle f = 1 kHz, amp = 1 V, offset = 1 V as shown in AWG1: T00004D8A001900000040<br>
      <br>
       Example stair f = 1 kHz, amp = 1 V, offset = 1 V as shown in AWG1: T00004D8F0F8300002710<br>
      <br>
	  </td></tr>
<tr><td style="vertical-align:top">"U"</td>
    <td> (length = 1) start sending data: chunks of block of data are sent: 
     AWG (aW), OSC1 (o1), OSC2 (o2), OSC3 (o3), OSC4 (o4); 16 bit each; 20 hex values <br>
     The first transmission has the current index (cP) stored. One extra transmission, 
	 because there can be an ongoing conversion at the current index.<br>	
     "U01230123012301230123YX01230123012301230123Y..."<br>
      U(o4)(o3)(cP)(o1)(AW)YX(o4)(o3)(o2)(o1)(AW)Y...<br>
    </td></tr>	  
<tr><td>"V"</td><td> Connect switches to output.</td></tr>
<tr><td style="vertical-align:top">"O"</td>
    <td> (length = 9) Oscilloscope block size 16 bit and sampling rate 16 Bit (V_06)<br>
      Command: O02000000 : Block size x0200 = 512; timeBase 0000 8.32 us (BASYS 3 XADC)</td></tr>
<tr><td style="vertical-align:top">"R"</td>
    <td> command transfers 8k data 16 bit hex data to lookup table for digital IOs<br>
     R0000..FFFF</td></tr>
<tr><td>"Q"</td><td> command activates the lookup table</td></tr>	 
</table>
<br>

 
</div>

<!---------------------- Arbitrary Waveform Generator 1 ------------------------------------------->
<div id="tab1" class="tabX" style="display:none">
  <h2> Arbitrary Waveform Generator 1</h2>
 <table >
 <tr><td class="bo" colspan="2">
     <span id="aRun"  style="display:block" onclick="aOp('Run')"><img src="ImagesS/Run.png" width="16"> Run  </span>
	 <span id="aStop" style="display:none"  onclick="aOp('Stop')"><img src="ImagesS/Stop.png" width="16"> Stop </span> </td>
 </tr>
 <tr>
   <td class="bo" align="center" bgcolor="#99e6ff" onclick="setWave(0);" id="dc"><img src="ImagesS/DC.png" width="32"><br>DC</td>
   <td class="bo" align="center" bgcolor="#FFFFFF" onclick="setWave(1);" id="sine"><img src="ImagesS/Sine.png" width="32"><br>Sine</td>
   <td class="bo" align="center" bgcolor="#FFFFFF" onclick="setWave(2);" id="rect"><img src="ImagesS/Rect.png" width="32"><br>Pulse</td>
   <td class="bo" align="center" bgcolor="#FFFFFF"  onclick="setWave(3);" id="triangle"><img src="ImagesS/Triangle.png" width="32"><br>Triangle</td>
   <td class="bo" align="center" bgcolor="#FFFFFF"  onclick="setWave(4);" id="stair"><img src="ImagesS/Stair1.png" width="32"><br>Stair</td>
   <td rowspan="4"> <canvas id="Ausgangssignal" width="400" height="300">   </canvas></td>
 </tr>

 <tr><td colspan="5">
  <div id="frequency" class="sliderE">
  </div>
 </td>
 </tr>

 <tr><td colspan="5">
  <div id="amplitude" class="sliderE">
  </div>
 </td></tr>

 <tr><td colspan="5">
  <div id="offset1" class="sliderE">
  <table>       <!-- Slider --->
  <tr>
   <td colspan="5">
     <div id="off1" class="slidecontainer">
	   <h4>Offset </h4>                         <!--- name --->
	   <input type="range" min="0" max="100" step="2" value="1" class="slider" id="offset1Slider" width="300">
	 </div>
   </td>
  </tr>
  <tr><td>Min</td><td align="center" colspan="2">Value </td><td>Max</td></tr>
  <tr>
   <td>
   <div id="offset1MinCT" style="display:block">
   <input type="text" value="0 V" size="5" id="offset1Min" onkeyup="readCR(e,'offset1','V')"/>  
   <img src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox('offset1','Min','CB',1,'V')"><br>
   </div>
   <div id="offset1MinCB" style="display:none">
     <select name="offset1MinS" id="offset1MinS" onchange="comboBox('offset1','Min','CT',1,'V')">
      <option value="5 V"> 5 V</option>
      <option value="4 V"> 4 V</option>
      <option value="3 V"> 3 V</option>
      <option value="2 V"> 2 V</option>
      <option value="1 V"> 1 V</option>
      <option value="500 mV"> 500 mV</option>
      <option value="200 mV"> 200 mV</option>
      <option value="100 mV">100 mV</option>
       <option value="0 V" selected>0 V</option>
     </select>
   </div>
   </td>    <!--- actual value ---->       
   <td colspan="2" align="center">
     <div id="offset1ValCT" style="display:block">
     <input type="text" value="1 V" size="5" id="offset1Val"  onkeyup="readCR(e,'offset1','V')"/>  
     <img src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox('offset1','Val','CB',1,'V')">
     </div>
     <div id="offset1ValCB" style="display:none">
      <select name="offset1ValS" id="offset1ValS" onchange="comboBox('offset1','Val','CT',1,'V')">
       <option value="5 V"> 5 V</option>  <option value="4 V"> 4 V</option>
       <option value="3 V"> 3 V</option>  <option value="2 V"> 2 V</option>
       <option value="1 V"> 1 V</option>
       <option value="500 mV"> 500 mV</option>
       <option value="200 mV"> 200 mV</option>
       <option value="100 mV">100 mV</option>
       <option value="0 V">0 V</option>
      </select>
     </div>
   </td>
   <td>  
     <div id="offset1MaxCT" style="display:block">
     <input type="text" value="1 V" size="5" id="offset1Max"  onkeyup="readCR(e,'offset1','V')"/>  
     <img src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox('offset1','Max','CB',1,'V')"><br>
     </div>
     <div id="offset1MaxCB" style="display:none">
      <select name="offset1MaxS" id="offset1MaxS" onchange="comboBox('offset1','Max','CT',1,'V')">
       <option value="5 V"> 5 V</option>
       <option value="4 V"> 4 V</option>
       <option value="3 V"> 3 V</option>
       <option value="2 V"> 2 V</option>
       <option value="1 V" selected> 1 V</option>
       <option value="500 mV"> 500 mV</option>
       <option value="200 mV"> 200 mV</option>
       <option value="100 mV">100 mV</option>
       <option value="0 V">0 V</option>
      </select>
     </div>
    </td>
   </tr>
   </table>
   </div>
   </td>
</tr>

</table>
<div id="cmd"></div>
<div id="step"></div>
<br><br><br><br><br><br><br><br><br><br><br>
Make change from V to code possible<br>
Number of periods per 64k? samples instead of frequency<br>
</div>

<!---------------------- Oscilloscope ------------------------------------------->
<div id="tab2" class="tabX" style="display:none">
  <h2> Oscilloscope</h2>
 <table class="bx">
 <tr><td class="bo" colspan="2">
     <span id="oRun"  style="display:block" onclick="oOp('Run')"><img src="ImagesS/Run.png" width="16"> Run  </span>
	 <span id="oStop" style="display:none"  onclick="oOp('Stop')"><img src="ImagesS/Stop.png" width="16"> Stop </span> </td>
 </tr>
 <tr><td class="bo">Acquisition </td><td class="bo">Average: 1</td>
     <td class="bo">Number of samples: 
	 	   <select id="dataMax" onclick="confOsc();">
   <!--   <option value="1" > 1</option> <option value="2"> 2</option>
      <option value="4" > 4</option> <option value="8"> 8</option> -->
      <option value="16" > 8 of 16</option>
	  <option selected value="512"> 256 of 512</option>
      <option value="1024" > 512 of 1024</option> 
	  <option value="2048"> 1024 of 2048</option>
      <option value="4096" >2048 of 4096</option> 
	  <option value="8192"> 4096 of 8192</option>
     </select>
     </td>
     <td class="bo"> xy  x-axis
      <select name="xyAxis" id="xyAxis" onchange="changeXAxis()">
       <option value="0" selected> Time </option>
       <option value="1"> AWG1 </option>
       <option value="2"> C1 </option>
       <option value="3"> C2 </option>
       <option value="4"> C3 </option>
       <option value="5"> C4 </option>
	  </select>
	 </td>
     <td class="bo"> Unit:
      <select id="currUnit" onchange="changeUnit()">
       <option value="0"> Code </option> 
       <option value="1" selected> Voltage </option>
	  </select>
	 </td>
 </tr>
 <tr>
   <td class="bo">Trigger</td>
   <td class="bo">Source &nbsp; 
      <select name="trgSrc" id="trgSrc">
       <option value="1"> AWG1 </option>
       <option value="2"> C1 </option>
       <option value="3"> C2 </option>
       <option value="4"> C3 </option>
       <option value="5"> C4 </option>
	  </select>
   </td>
   <td class="bo">Condition &nbsp; 
      <select name="trgEdge" id="trgEdge">
       <option value="1"> Rising </option>
       <option value="2"> Falling </option>
       <option value="3"> Ramp up </option>
	  </select>
   </td>
   <td class="bo"><table><tr><td>Level</td><td>
     <input type="text" value="1 V" size="5" id="trigLevelVal"></td><td>
	 <img id="trigLevelValCT" style="display:block" src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox('trigLevel','Val','CB',0,'V')">
	 <span id="trigLevelValCB" style="display:none">
      <select name="trigLevelValS" id="trigLevelValS" onchange="comboBox('trigLevel','Val','CT',0,'V')">
       <option value="3 V" > 3 V</option>
       <option value="2 V" > 2 V</option>
       <option value="1 V" selected > 1 V</option>
       <option value="500 mV"> 500 mV</option>
     </select>
     </span>  </td></tr>
	 </table> 
   </td>
 </tr>
</table>
<table>
<tr>
<td  class="top">
 <table>
 <tr> <td>X Axis</td></tr>
 <tr> <td class="bo0" id="time"><input type="checkbox" id="cTime" value="value" checked> Time<br>
 	    <table><tr><td>
		  Position: </td><td><input type="text" value="0 s" size="5" id="posVal" onkeyup="readCRX(e,'pos','s')"></td><td> 
		  <img id="posValCT" style="display:block" src="ImagesS/SelectListA.png" width="16" height="16" 
		       onclick="comboBox('pos','Val','CB',2,'s')">
          <div id="posValCB" style="display:none">
          <select id="posValS" onchange="comboBox('pos','Val','CT',2,'s')"></select>
		  </div>
		  </td></tr>
		  <tr><td>Base: </td><td><input type="text" value="200 us/div" size="5" id="baseVal" onkeyup="readCRX(e,'base','s/div')"></td><td> 
		  <img id="baseValCT" style="display:block" src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox('base','Val','CB',2,'s')">
          <div id="baseValCB" style="display:none">
          <select id="baseValS" onchange="comboBox('base','Val','CT',2,'s')"></select>
          </div>
		  </td></tr>
		  </table>
 </td></tr>
 <tr> <td>=====&nbsp;Y&nbsp;Axis&nbsp;&nbsp;===========</td></tr>
 <tr> <td class="bo1" id="AWG1">
        <input type="checkbox" id="cAWG1" value="value" checked onclick="toggleCheck('AWG1',1)">
	      AWG1 Unit: 
	  </td></tr>
 <tr> <td class="bo2" id="C1">
        <input type="checkbox" id="cC1" value="value">
	      C1
	  </td></tr>
 <tr> <td class="bo3" id="C2">
        <input type="checkbox" id="cC2" value="value">
	      C2</td></tr>
 <tr> <td class="bo4" id="C3">
        <input type="checkbox" id="cC3" value="value">
	      C3</td></tr>
 <tr> <td class="bo5" id="C4">
        <input type="checkbox" id="cC4" value="value">
	      C4</td></tr>
 <tr> <td class="bo6" id="M1">
        <input type="checkbox" id="cM1" value="value">
	      M1</td></tr>
 </table>
</td> 
   <td class="top" rowspan="6"> 
   <table>
   <tr><td class="bo1" onclick="activeChan(1)">AWG</td><td class="bo2" onclick="activeChan(2)">C1</td>
       <td class="bo3" onclick="activeChan(3)">C2</td><td class="bo4" onclick="activeChan(4)">C3</td>
	   <td class="bo5" onclick="activeChan(5)">C4</td><td class="bo6" onclick="activeChan(6)"> M1</td>
	   <td> <div id="statusOSC"></div></td>
   </tr>
   </table>
            <canvas id="OSC" width="600" height="350"></canvas><br>
			<span id="mouse">Mouse</span>
			<span id="dataXY">Data XY</span>
			</td>
<td class="top">
 <div id="measureOSC"></div>
</td> 

</tr>
</table>
<span style="background-color:#cce6ff;" onclick="generateData()">Load data</span>&nbsp;&nbsp; 
<span style="background-color:#cce6ff;" onclick="saveData()">Save data</span><br>
<br>
Offset, range list<br>
connect input to chart<br>
X,Y Cursors<br>
Math function, Fit function<br>
<div id="data" style="display:block"></div>
</div>

<!---------------------- FFT --------------------------------------------------------->
<div id="tab3" class="tabX" style="display:none">
<h2>FFT</h2>
 <table class="bx">
 <tr><td class="bo">
     <span id="fRun"  style="display:block" onclick="fOp('Run')"><img src="ImagesS/Run.png" width="16"> Run  </span>
	 <span id="fStop" style="display:none"  onclick="fOp('Stop')"><img src="ImagesS/Stop.png" width="16"> Stop </span> </td>
 </tr>
  <tr>
   <td class="bo">Channel &nbsp; 
      <select name="fftSrc" id="fftSrc" onclick="calcHarmonics()">
       <option value="1"> AWG1 </option>
       <option value="2"> C1 </option>
       <option value="3"> C2 </option>
       <option value="4"> C3 </option>
       <option value="5"> C4 </option>
	  </select>
   </td>
  </tr>
  <tr>
  <td class="top"><div id="fftList">
     <table><tbody><tr><td>Magnitude List Channel: </td><td class="bo2">C1</td></tr></tbody></table>  
     <table border="1"><tbody><tr><td class="bo">Index</td><td class="bo">f in Hz</td><td class="bo"> signal<br> magnitude<br> dB</td><td class="bo"> Total<br> noise<br> magnitude<br> dB </td></tr>
	 </tbody></table>
  </div></td>
  <td class="top"> FFT Chart<br>  <canvas id="fftChart" width="600" height="350"></canvas><br>
  </td>
  </tr>
</table>
<div id="infoX">
</div>
</div>

<!---------------------- Histogram --------------------------------------------------------->
<div id="tab4" class="tabX" style="display:none">
<h2>Histogram</h2>
 <table class="bx">
 <tr><td class="bo">
     <span id="hRun"  style="display:block" onclick="hOp('Run')"><img src="ImagesS/Run.png" width="16"> Run  </span>
	 <span id="hStop" style="display:none"  onclick="hOp('Stop')"><img src="ImagesS/Stop.png" width="16"> Stop </span> </td>
 </tr>
  <tr>
   <td id="bins" class="bo">Bins &nbsp; 
      <select name="binsVal" id="binsVal">
       <option value="16"> 16 </option>
       <option value="64"> 64 </option>
       <option value="256"> 256 </option>
       <option value="1024"> 1024</option>
       <option value="65536"> 65536 </option>
	  </select>
   </td>
 </tr>
  <tr>
  <td class="top"> Histogram<br>  <canvas id="histoChart" width="600" height="350"></canvas><br>
  <div id="binsTab"></div>
  </td>
  </tr>
</table>

</div>

<!---------------------- INL, DNL DAC --------------------------------------------------------->
<div id="tab5" class="tabX" style="display:none">
<h2>Ramp Test INL and DNL</h2>
<br>
BASYS3 has 16 bit R2R 3.3 V DAC and 4k lookup table.<br>
For 1 V maximum input range the maximum end code value is: 19858<br>
Therefore step size is 19858/4096 = 5<br>
<br>
<table class="bx">
 <tr><td class="bo" colspan="2">
     <span id="rRun"  style="display:block" onclick="rOp('Run')"><img src="ImagesS/Run.png" width="16"> Run  </span>
	 <span id="rStop" style="display:none"  onclick="rOp('Stop')"><img src="ImagesS/Stop.png" width="16"> Stop </span> </td>
 </tr>
  <tr>
  <td class="bo">
  Step (Default 5):</td><td>
     <input type="text" value="5" size="6" id="codesStep"/>  </td>
    </tr>
  <tr><td class="bo">
    Start Code (Default 0): </td><td><input type="text" value="0" size="6" id="codesStart"/>  <br>
  </td>
  </tr>
  <tr><td class="bo">
    End Code (Default 19858):</td><td><input type="text" value="19858" size="6" id="codesEnd"/>  <br>
  </td>
  </tr>
  <tr>   <td class="bo">
      <input type="checkbox" id="cLook" value="value" > Calculate Lookup table<br> <!-- checked -->
     <input type="text" id="stepScale" value="1.0" > Maximum step scaling 0.66..1.0<br> <!-- Range 0.66..1.0 -->
	  Calculate for Channel &nbsp; 
      <select name="rampSrc" id="rampSrc" onclick="ramp()">
       <option value="1"> AWG1 </option>
       <option value="2"> C1 </option>
       <option value="3"> C2 </option>
       <option value="4"> C3 </option>
       <option value="5"> C4 </option>
	  </select>
   </td>
  </tr>
  <tr><td colspan="4">
    <div id="inlResult"></div>
    <canvas id="inlChart" width="800" height="350"></canvas>
    <canvas id="dnlChart" width="800" height="350"></canvas><br>
    <canvas id="rampChart" width="800" height="350"></canvas><br>
	Click on Chart to get a data table<br><br>
    <canvas id="rampX" width="800" height="350" style="display:none"></canvas>
    <canvas id="rampY" width="800" height="350" style="display:none"></canvas>
  </td>
  </tr>
</table>  
<div id="bestL"></div><br>
</div>

<!---------------------- Lookup Table --------------------------------------------------------->
<div id="tab6" class="tabX" style="display:none">
<h2>Lookup Table</h2>
<br> 
There should be 256 8 Bit (Arduino), 8k 16 Bit values (BASYS3) comma 
separated values in the text input field.<br>
<br>
<textarea id="lookupX" name="lookupX" rows="8" cols="128">
</textarea><br>
<input type="submit" value="Submit" onclick="sendLookup();"></input>
<br>
<input type="submit" value="Reset table" onclick="defaultLookup(0);"></input><br>
<input type="submit" value="Reverse table" onclick="defaultLookup(1);"></input><br>
<input type="submit" value="Rounded" onclick="defaultLookup(3);"></input><br>
<br>
<input type="submit" value="Activate" onclick="activateLookup();"></input>
<br>
<input type="submit" value="Deactivate" onclick="deactivateLookup();"></input>
<br>
  Fixed value:</td><td>
     <input type="text" value="1" size="6" id="lookupVal"/><br>
<input type="submit" value="Fixed value" onclick="defaultLookup(2);"></input>
<br>
</div>

<div id="tab7" class="tabX" style="display:none">
<h2>Settling time</h2>
</div>

<div id="tab8" class="tabX" style="display:none">
<h2>Power supply</h2>
</div>

<div id="tab9" class="tabX" style="display:none">
<h2>Bodeplot</h2>
</div>

<div id="tab10" class="tabX" style="display:none">
<h2>Digital I/O</h2>
</div>

<div id="tab11" class="tabX" style="display:none">
<h2>Applications</h2>

IV curves: R, Diode, transistor, opamp, inverter<br>
Time operation: C, L, diode, transistor, inverter<br>
Bodeplot: passive and active Filters<br>
Power supply, SC circuits<br>
AD and DA converter<br>
Digital circuits, logic functions, multiplexer and encoder<br>
State machines, Counters, serializer and deserializer, memories<br> 
Microprocessors<br>
Digital signal processing and control loops<br>
</div>

<script>

 var srcX = ["AWG","OSC4", "OSC3","OSC2","OSC1"];
 var dataOSC = [];  // expecting 512 times 5 data points
 var dataIndex = 1;

var curveTyp = 1;
var e;                // event
var aXY = [];         // x y values AWG
var aGrN = 64;        // number of xy values AWG
var aState = "Stop";  // awg1 state
var oState = "Stop";  // oscilloscope state
var fState = "Stop";  // FFT state
var hState = "Stop";  // histogram state
var rState = "Stop";  // ramp test INl, DNL state
var busy = 0;
var timeBase = 0; // timeBase 0 every cycle, 1 every second cycle sampling cms send via sendCmdC cmdTxT.value
var trgPos = -1;  // Trigger position

// range
var voltRange = ["5 V","4 V","3 V","2 V","1 V","900 mV", "800 mV", "700 mV", "600 mV",
                 "500 mV","400 mV","300 mV","200 mV","100 mV","80 mV","60 mV","50 mV","0 V",
				 "-50 mV","-60 mV","-80 mV","-100 mV","-200 mV","-300 mV","-400 mV","-500 mV",
				 "-600 mV","-700 mV","-800 mV","-900mV","-1 V","-2 V","-3 V","-4 V","-5 V"];
var voltDivRange = ["5 V/div","4 V/div","3 V/div","2 V/div","1 V/div","500 mV/div", "200 mV/div", "100 mV/div",
                 "50 mV/div","10 mV/div","5 mV/div","2 mV/div","1 mV/div","500 uV/div","100 uV/div"];
var timeRange = ["-1 s", "-500 ms", "-200 ms", "-100 ms", "-50 ms", "-20 ms","-10 ms", "-5 ms", 
                 "-2 ms", "-1 ms", "-500 us",  "-200 us", "-100 us", "-50 us",  "-10 us", "-5 us",
				 "0 s", "5 us", "10 us", "50 us", "100 us", "500 us", "1 ms", "5 ms", "10 ms",
				 "50 ms", "100 ms", "500 ms", "1 s"];
var timeBaseRange = ["1 s/div", "500 ms/div", "200 ms/div", "100 ms/div", "50 ms/div", "20 ms/div",
                 "10 ms/div", "5 ms/div", "2 ms/div", "1 ms/div", "500 us/div",  "200 us/div",
				  "100 us/div", "50 us/div",  "10 us/div", "5 us/div"];
var frequencyRange = ["5 MHz","2 MHz","1 MHz","500 kHz","200 kHz","100 kHz", "50 kHz", "20 kHz", "10 kHz",
                 "5 kHz","2 kHz","1 kHz","500 Hz","200 Hz","100 Hz","50 Hz","20 Hz","10 Hz",
				 "5 Hz","2 Hz","1 Hz","500 mHz","200 mHz","100 mHz","50 mHz","20 mHz",
				 "10 mHz","5 mHz","2 mHz","1mHz","500 uHz","200 uHz","100 uHz"];
var codeRange = [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072];
var codePos = [-16,-32,-64,-128,-256,-512,-1024,-2048,-4096,-8192,-16384,-32768,-65536,-131072];

function tabAct(x) { // show only active tab
  // class tbs -> tb, x class member tb -> tbs
  var tabClass = document.getElementsByClassName("tbs");
  var tabClassDiv = document.getElementsByClassName("tabX");
  for (var i = 0; i < tabClass.length; i++) {
     tabClass[i].classList.add("tb");
     tabClass[i].classList.remove("tbs");
  }
  for (var i = 0; i < tabClassDiv.length; i++) {
	 tabClassDiv[i].style.display = "none";
  }
  // alert(x + "," + tabClass.length);
  tabClass = document.getElementsByClassName("tb");
  // alert(x + "," + tabClass.length);
  tabClass[x].classList.add("tbs");
  tabClass[x].classList.remove("tb");
  tabClassDiv[x].style.display = "block";

}

function selectBoard() {
  // 0 FPGA 1 Simulation 2 Arduino 3 RaspberryPi 4 Infineon
  var boardX = document.getElementById("board").value;
  document.getElementById("board0").style.display = "none";
  document.getElementById("board2").style.display = "none";
  if (boardX == 0) {
    document.getElementById("board0").style.display = "block";
    document.getElementById("timeSampling").value = valueToUnit(8.32E-6) + "s";
  } else if (boardX == 2) {
    document.getElementById("board2").style.display = "block";
    document.getElementById("timeSampling").value = valueToUnit(380E-6) + "s";
  }
}

function aOp(cmd) {  // AWG operation
  if (cmd == "Run") {
    document.getElementById("aStop").style.display="block";
    document.getElementById("aRun").style.display="none";
	// Action 
    genCmdAWG();      // update command
	// check simulation?
	sendCmd();        // send command
	aState = "Run";
  } else {
    var cmdTemp =  document.getElementById("cmd").innerHTML;
    document.getElementById("cmd").innerHTML ="X";
    document.getElementById("aRun").style.display="block";
    document.getElementById("aStop").style.display="none";
	// Action missing
	sendCmd();
	document.getElementById("cmd").innerHTML = cmdTemp;
	aState = "Stop";
  }
}

var handlerOsc;
var busyOsc = 0;

function runOsc() {
   if (busyOsc == 0 ) {
     document.getElementById("cmd").innerHTML ="U";   // send command to send data
	 sendCmd();
	 busyOsc = 1;  // new data going on
   }	
}

function oOp(cmd) {  // oscilloscope reading
  var cmdTemp =  document.getElementById("cmd").innerHTML;
  if (cmd == "Run") {
    document.getElementById("cmd").innerHTML ="U";   // send command to send data
    document.getElementById("oStop").style.display="block";
    document.getElementById("oRun").style.display="none";
	// Action 
	sendCmd();
	oState = "Run";  
	dataIndex = 0;
	// handlerOsc = setTimeout(runOsc,2000);
	handlerOsc = setInterval(runOsc,2000);
  } else {
    // document.getElementById("cmd").innerHTML ="X";
    document.getElementById("oRun").style.display="block";
    document.getElementById("oStop").style.display="none";
	// Action
	// sendCmd();
	oState = "Stop";
	clearInterval(handlerOsc);
  }
  document.getElementById("cmd").innerHTML = cmdTemp;
}

function fOp(cmd) {  // oscilloscope reading
  if (cmd == "Run") {
    document.getElementById("fStop").style.display="block";
    document.getElementById("fRun").style.display="none";
    fState="Run";
	generateFFT();
  } else {
    document.getElementById("fStop").style.display="none";
    document.getElementById("fRun").style.display="block";
    fState="Stop";
  }
}

function hOp(cmd) {  // oscilloscope reading
  if (cmd == "Run") {
    // document.getElementById("hStop").style.display="block";
    // document.getElementById("hRun").style.display="none";
    // hState="Run";
	generateHisto();
  } else {
    document.getElementById("hStop").style.display="none";
    document.getElementById("hRun").style.display="block";
    hState="Stop";
  }
}

function rOp(cmd) {  // oscilloscope reading
  if (cmd == "Run") {
    document.getElementById("rStop").style.display="block";
    document.getElementById("rRun").style.display="none";
    rState="Run";
	generateRamp();
  } else {
    document.getElementById("rStop").style.display="none";
    document.getElementById("rRun").style.display="block";
    rState="Stop";
  }
}

function readCR(key,id,unit) {
	if (!key) {	key = event; key.which = key.keyCode; }
	if (key.which == 13) { updateSlider(id,unit);}
}

function readCRH(key,id,unit) {
	if (!key) {	key = event; key.which = key.keyCode; }
	if (key.which == 13) { generateHisto();}
}

function setWave(nr) {
  // alert(nr);
  var wNames = ["dc","sine","rect","triangle","stair"];
  curveTyp = nr;
  for (var i = 0; i < wNames.length; i++) {
     if (i == nr) {
       document.getElementById(wNames[i]).style.backgroundColor = "#99e6ff";
	 } else {
       document.getElementById(wNames[i]).style.backgroundColor = "#FFFFFF";
     }	 
  }
  // Missing disable Frequency Amplitude for DC
  plotAWG();
}


// Evaluates a text input with arrow with list id=offset1Min, offset2Min 
function comboBox(id,minmax,nr,slider,unit) {
  if (nr == "CT") {    // activate text input
    document.getElementById(id + minmax + "CT").style.display="block";
    document.getElementById(id + minmax + "CB").style.display="none";
	// change selected value in List 
	document.getElementById(id + minmax).value = document.getElementById(id + minmax + "S").value; 
  } else {          // activate List
    document.getElementById(id + minmax + "CT").style.display="none";
    document.getElementById(id + minmax + "CB").style.display="block";
	// change value in text input 
	var valX = findNextOption(id + minmax + "S",document.getElementById(id + minmax).value);
	document.getElementById(id + minmax + "S").value = valX;  
	if  (((minmax == "Max") && (document.getElementById(id + "Val").value > valX) ) 
	     || ((minmax == "Min") && (document.getElementById(id + "Val").value < valX) )){
	    document.getElementById(id + "Val").value = valX;
	}	
  }
  if (slider == 1) { updateSlider(id,unit); }
  if (slider == 2) {  // update oscillocope callback better??
     // like  readCRX 
     updateOSC()
  }  
  if (slider == 3) { generateHisto(); }
}

// Example: txtV = "200 ms/div" txtV = "1 uV"
// return           2E-4                1E-6
function unitToValue(txtV) { 
  var text = txtV.split(" ");  // number and unit
  // alert("x" + txtV + "x");
  var scale = 1;
  if (text.length == 0) {
    text[0] = "0";
  } else if (text.length > 1) {
    var unit = text[1].substring(0,1); // get unit scaling 
    if (unit == "T") { scale = 1E12; }
    else if (unit == "G") { scale = 1E9; }
    else if (unit == "M") { scale = 1E6; }
    else if (unit == "k") { scale = 1E3; }
    else if (unit == "m") { scale = 1E-3; }
    else if (unit == "u") { scale = 1E-6; }
    else if (unit == "n") { scale = 1E-9; }
    else if (unit == "p") { scale = 1E-12; }
  }
  return parseFloat(text[0])*scale;
}

function valueToUnit(val) {
    var valabs = Math.abs(val);
	var scale = 1;
	var mod ="";
    if (valabs >= 1E12) { mod = "T"; scale = 1E12; }
    else if (valabs >= 1E9) { mod = "G"; scale = 1E-9; }
    else if (valabs >= 1E6) { mod = "M"; scale = 1E-6; }
    else if (valabs >= 1E3) { mod = "k"; scale = 1E-3; }
    else if (valabs >= 1) { mod = ""; scale = 1; }
    else if (valabs >= 1E-3) { mod = "m"; scale = 1E3; }
    else if (valabs >= 1E-6) { mod = "u"; scale = 1E6; }
    else if (valabs >= 1E-9) { mod = "n"; scale = 1E9; }
    else if (valabs >= 1E-12){ mod = "p"; scale = 1E12; }
    else { mod = ""; scale = 0; }
	return (val*scale).toPrecision(3) + " " + mod;
}

function findNextOption(optionId,valueU) {
  var selectBoxEl = document.getElementById(optionId);
  var arrayOfNodes = selectBoxEl.childNodes;
  var optionsArr = [];
  // loop through child Nodes and only get option nodes
  for (var i = 0; i < arrayOfNodes.length; i++) {
	if (arrayOfNodes[i].nodeName === 'OPTION') {
  	  optionsArr.push(arrayOfNodes[i].value);
    }
  }
  // alert(optionsArr);
  var select = optionsArr[0];
  var delta = Math.abs(unitToValue(optionsArr[0]) - unitToValue(valueU) );
  for (var i = 1; i < optionsArr.length; i++) {
     var delta1 = Math.abs(unitToValue(optionsArr[i]) - unitToValue(valueU) );
	 if (delta1 < delta) {
	    select = optionsArr[i];
		delta = delta1;
	 }
  }
  return select;
}


function updateSlider(id,unit) { // From Min Value Max list limit Value
    // Min update slider
	var minXE = unitToValue(document.getElementById(id+"Min").value);
	// alert(minXE);
	document.getElementById(id+"Slider").min = minXE
    // Max update slider
	var maxXE = unitToValue(document.getElementById(id+"Max").value);
	if (maxXE < minXE) {   // Max greater than Min
	    maxXE = minXE; 
		document.getElementById(id+"Max").value = valueToUnit(maxXE) + unit;
	}
	document.getElementById(id+"Slider").max = maxXE
    // Step
	document.getElementById(id+"Slider").step = (maxXE - minXE)/50;
	// value
	var val = unitToValue(document.getElementById(id + "Val").value);
	document.getElementById(id + "Slider").value = val;
	if (val > maxXE) { val = maxXE; }
	if (val < minXE) { val = minXE; }
    // position	
	document.getElementById(id + "Slider").value = val;
	document.getElementById(id + "Val").value = valueToUnit(val) + unit;
	// update curve
	plotAWG();
}

function slider(id,unit) {
var dslider = document.getElementById(id+"Slider");		//Slider
var d = document.getElementById(id + "Val");
  d.value = valueToUnit(dslider.value) + unit;          // update Value
  dslider.oninput = function(){
	d.value = valueToUnit(this.value) + unit;
	// update graph
    plotAWG();
  }
}


function createSlider(id,range,unit) { // Misisng unit V HZ and range name function comboBox readCR
var xList = ["Min","Val","Max"];
var nSlider = document.getElementById(id);		// create Slider with min, value max
var innerTxt = "<table>\n"      
             + " <tr>"
             + "<td colspan='4'>"       
	         + "<div id='off1' class='slidecontainer'>"
	         + "<h4>" + id[0].toUpperCase() + id.substring(1) + "</h4>"
	         + '<input type="range" min="' + unitToValue(range[range.length - 1]) + '" max="' + unitToValue(range[0]) 
			 + '" step="2" value="' + unitToValue(range[Math.trunc(range.length/2)]) + '" class="slider" id="' + id + 'Slider" width="300">'
	         + '</div>'
             + '</td>'
             + '</tr>'
             +' <tr><td>Min</td><td align="center">Value </td><td>Max</td></tr>'
             + '<tr>';
	for (var j = 0; j < xList.length; j++) {
      var valX = range[range.length - 1];
	  if (xList[j] == "Val") valX = range[Math.trunc(range.length/2)];
	  if (xList[j] == "Max") valX = range[0];
      innerTxt = innerTxt + '<td>'
             + '<div id="' + id + xList[j] +'CT" style="display:block">'
             + '<input type="text" value="' + valX + '" size="5" id="' + id + xList[j] + '" onkeyup="readCR(e,' + "'" + id +"','" + unit + "'" +')"/>\n'  
             + '<img src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox(' + "'" + id + "'" + ',' + "'" 
			  + xList[j] + "'" +','+ "'" + 'CB' + "'" +',1,'+ "'" + unit + "'" + ')">'
             + '</div>'
             + '<div id="' + id + xList[j] + 'CB" style="display:none">'
             + '<select name="' + id + xList[j] + 'S" id="' + id + xList[j] + 'S" onchange="comboBox('+ "'" + id + "','" 
	               + xList[j] + "','"+'CT' + "',1,'" + unit + "')" +'">';
      for (var i = 0; i < range.length; i++) {
         innerTxt +='<option value="' + range[i] + '" >' + range[i] + '</option>';
      }			 // Value combo box
      innerTxt = innerTxt + '</select>'
             + '</div>'
             + '</td>';       
    }
    innerTxt = innerTxt + '</tr></table>'
	nSlider.innerHTML = innerTxt;
}

function createComboBox(name,id,range,unit,slider) {
var nCombo = document.getElementById(id);		// create ComboBox only
var valX = range[range.length - 1];
var selX = "";

var innerTxt = "<table>\n"      
             + " <tr><td>" + name + "</td>";
    innerTxt = innerTxt + '<td>'
             + '<div id="' + id +'ValCT" style="display:block">';
    if (slider == 3) {          // no update slider with readCR
	  innerTxt += '<input type="text" value="' + valX + '" size="5" id="' + id + 'Val" onkeyup = "readCRH(e,' + "'" + id +"','" + id +"'" +')"/>\n'  
    } else {
	  innerTxt += '<input type="text" value="' + valX + '" size="5" id="' + id + 'Val" onkeyup = "readCR(e,' + "'" + id +"','" + id +"'" +')"/>\n'  
    }
	innerTxt += '<img src="ImagesS/SelectListA.png" width="16" height="16" onclick="comboBox(' + "'" + id + "'" + ',' + "'" 
			 + "Val'" +','+ "'" + 'CB' + "'" +',' + slider + ','+ "'" + unit + "'" + ')">'
             + '</div>'
             + '<div id="' + id + 'ValCB" style="display:none">'
             + '<select name="' + id + 'ValS" id="' + id + 'ValS" onchange="comboBox('+ "'" + id + "','" 
	               + "Val','"+'CT' + "','" + slider + "','" + id +"')" +'">';
      for (var i = 0; i < range.length; i++) {                  // create options from range
		 innerTxt +='<option value="' + range[i] + '" >' + range[i] + '</option>';
      }			 // Value combo box
      innerTxt = innerTxt + '</select>'
             + '</div>'
             + '</td>';       
    innerTxt = innerTxt + '</tr></table>'
	nCombo.innerHTML = innerTxt;
}

window.addEventListener("load",createSlider('amplitude',voltRange,'V'));
window.addEventListener("load",createSlider('frequency',frequencyRange,'Hz'));
window.addEventListener("load",slider('offset1','V'));
window.addEventListener("load",updateSlider('offset1','V'));
window.addEventListener("load",slider('amplitude','V'));
window.addEventListener("load",updateSlider('amplitude','V'));
window.addEventListener("load",slider('frequency','Hz'));
window.addEventListener("load",updateSlider('frequency','Hz'));
window.addEventListener("load",setWave(1));

// window.addEventListener("load",alert(findNextOption('offset1ValS','100 mV')));
function decToHex(x,d) {
   var hexN = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"];
   var hex = "";
   var num = Math.round(x);
   var div;
   var rest;
   for (var i = 0; i < d; i++) {    //  d hex digits
       div = Math.trunc(num/16);
	   rest = num % 16;
	   // alert(num +"x" + div + "x" + rest);
	   hex = hexN[rest] + hex;  // LSB...MSB
	   num = div;
   }
   return hex;
}

function DecHexValue(x) {
 if (x=="A") { return 10; } else if (x=="B") {  return 11;
 } else if (x=="C") { return 12; } else if (x=="D") {  return 13;
 } else if (x=="E") {return 14; } else if (x=="F") {  return 15;
 } else { return parseInt(x); }
}

function hexToDec(x) {
   var hexN = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"];
   var dec = 0;
   for (var i = 0; i < x.length; i++) {    //  8 hex digits
      dec = dec * 16 + DecHexValue(x[i]); 
   }
   return dec;
}

function isPrime (n) {
   if (n===1){
      return false;
   }else if(n === 2){
      return true;
   }else{
      for(let x = 2; x < n; x++){
         if(n % x === 0){
            return false;
         }
      }
      return true;
   };
};

function nearestPrime(num) {
   while(!isPrime(++num)){};
   return num;
};

function genCmdAWG() {  // generate serial command for BASYS3
  var cmd = "";
  var maxV = 3.3;
  var maxC = 32767;
  var fCalc = 1E8; // 100 MHz update of calculation
  var frequency = unitToValue(document.getElementById("frequencyVal").value);
  var amp = unitToValue(document.getElementById("amplitudeVal").value);
  var off = unitToValue(document.getElementById("offset1Val").value);
  var dataMax = parseInt(document.getElementById("dataMax").value);
  var start;   // Triangle parameters
  var stop;
  var step;
  var repeat;
  var ampC;
  var offC;
  var infoX ="";
  infoX = "Frequency: " + valueToUnit(frequency) ;
  var nSample = 13 * 128;  
  // board management
  var boardX = parseInt(document.getElementById("board").value);
  // alert(boardX);
  if (boardX == 0) { // FPGA
         // document.getElementById("timeSampling").value = 8.32E-6;
	     nSample = 13 * 128; // 8.32us / 10 ns * 2 FGA = Math.trunc(8.32E-6/10E-9*2) 
		 maxC = 32767;
  } else if (boardX == 2) { // Arduino
         // document.getElementById("timeSampling").value = 360E-6;
	     nSample = 78000 * 5; // 360us / 10 ns * 2 Arduino Maker WiFi = Math.trunc(360E-6/10E-9 * 2 * 3) 
         maxC = 4095;
		 timeBase = 1;
		 fCalc = 1E8 / 6; 
  }

	if (curveTyp == 0) {  // DC
	   cmd = "T";         // triangle as DC with start = stop
	   start = Math.trunc(maxC / maxV * off);
       cmd = cmd + 	decToHex(start,4);   
       cmd = cmd + 	decToHex(start,4);  // stop =start DC   
       cmd = cmd + 	"0000";       // before 0000 FPGA working??     
       cmd = cmd +  "00020000";  // doesn't matter
	   stop = start; step = 0; repeat = 512;
	} else if (curveTyp == 1) {  // Sine
	   cmd = "S"; // Sine
	   ampC = Math.trunc( (2*1024*1024*1024-1) / maxV * amp); // Range 0.. 2^30
       offC = Math.trunc( (2*1024*1024*1024-1) / maxV * off);
       if (offC >= 2*1024*1024*1024) { offC = 2*1024*1024*1024-1; }
	   if ((offC + ampC) >= 2*1024*1024*1024) { ampC = 2*1024*1024*1024-1-offC; } 	   
	   if ((offC - ampC) < 0) { ampC = offC; }
	   // correct step with better frequency for good fft
	   // timeBase = 4 fft good 256 samples, 1 ms/div time base oscilloscope
	   var timeX = (timeBase + 1)/4; // (timeBase + 1)/3; // 
	   // fix nCycle to odd (prime)
	   var nCycle = Math.round(dataMax / fCalc * timeX * nSample * frequency); // number of cycles
	   if ((nCycle % 2) == 0) { nCycle = nCycle + 1; }
	   var frequency1 = nCycle * fCalc / dataMax / nSample / timeX; // odd corrected frequency
       frequency = nearestPrime(nCycle) * fCalc / dataMax / timeX / nSample; // prime corrected frequency	   
       infoX = infoX + " is mapped to " + valueToUnit(frequency1) 
	           + " prime " + valueToUnit(frequency) + " <br>\n"
			   + " Cycles " + nCycle ;
	   // end correct step size
	   step = Math.trunc(1024 * 1024 * 8 / fCalc * nSample * frequency);
	   // step = 100900;
	   cmd = cmd + 	decToHex(step,8);   // step makes frequency
       cmd = cmd + 	decToHex(ampC,8);   // amplitude
       cmd = cmd + 	decToHex(offC,8);  // offset  
       start = offC - ampC; stop = offC + ampC; repeat = 0;	   
	} else if (curveTyp == 2) {  // Pulse
	   cmd = "T";                // triangle as pulse 
	   start = Math.trunc(maxC / maxV * (off-amp));  // start voltage to code
	   stop = Math.trunc(maxC / maxV * (off+amp));   // stop voltage to code
	   if (start < 0) start = 0;                     // no negative code
	   if (stop > maxC) stop = maxC;                 // stop limited by maximum code
	   step = stop - start;                          // adjust step to difference
	   repeat = Math.trunc(1 / frequency / 2 * fCalc);    // 1E8 fFPGA 
	   // alert(repeat);
       cmd = cmd + 	decToHex(start,4);   
       cmd = cmd + 	decToHex(stop,4);  // stop =start DC   
       cmd = cmd + 	decToHex(step,4);     
       cmd = cmd +  decToHex(repeat,8);  // frequency
   	} else if (curveTyp == 3) {  // Triangle 
	   var repMax = 64;          // When does step change from 1 to another number
	   cmd = "T"; // triangle 
	   start = Math.trunc(maxC / maxV * (off-amp));
	   stop = Math.trunc(maxC / maxV * (off+amp));
	   if (start < 0) start = 0;
	   if (stop > maxC) stop = maxC;
	   repeat = 1 / frequency / (stop-start) / 2 * fCalc;    // 1E8 fFPGA 
	   // alert(repeat);
	   if (repeat >= repMax) { 
	      repeat = Math.trunc(repeat); 
	      step = 1;
	   } else {	   
	      step = Math.trunc(repMax / repeat);
		  stop = Math.trunc((stop-start)/step)*step + start;
		  repeat = repMax;
	   }	  
	   cmd = cmd + 	decToHex(start,4);   
       cmd = cmd + 	decToHex(stop,4);  // stop =start DC   
       cmd = cmd + 	decToHex(step,4);     
       cmd = cmd +  decToHex(repeat,8);  // frequency
	} else if (curveTyp == 4) {  // Stair   
	   cmd = "T"; // triangle 
	   start = Math.trunc(maxC / maxV * (off-amp));
	   stop = Math.trunc(maxC / maxV * (off+amp));
	   if (start < 0) start = 0;
	   if (stop > maxC) stop = maxC;
	   repeat = Math.trunc(1 / frequency / 2 * fCalc / 5);    // 1E8 fFPGA 
       if (repeat == 0) { 
	      repeat = 1;      // ??	   
	   } else {	   
	      step = Math.trunc((stop-start)/5);
		  stop = Math.trunc((stop-start)/step)*step + start;
	   }	  
	   cmd = cmd + 	decToHex(start,4);   
       cmd = cmd + 	decToHex(stop,4);  // stop =start DC   
       cmd = cmd + 	decToHex(step,4);     
       cmd = cmd +  decToHex(repeat,8);  // frequency
	}
	document.getElementById("infoX").innerHTML = infoX;
	document.getElementById("cmd").innerHTML = cmd;
	document.getElementById("step").innerHTML = "Start: " + start + " Stop: " + stop
	   + " Step: " + step + " Repeat: " + repeat;
}

function plotAWG() {
  // curveTyp  global variable 0 DC, 1 Sine, 2 rect, 3 Triangle 
  var xStart, xStop, xStep;
  var yAmp, yOff; 
  
  xStart = 0;
  xStop = 1/unitToValue(document.getElementById("frequencyVal").value);
  xStep = (xStop - xStart)/aGrN;
  yAmp = unitToValue(document.getElementById("amplitudeVal").value);
  yOff = unitToValue(document.getElementById("offset1Val").value);
  
  for (var i = 0; i < aGrN; i++) {		
	aXY[i] = i*xStep;
	if (curveTyp == 0) {
	   aXY[i+aGrN] = yOff;
	} else if (curveTyp == 1) {   
	   aXY[i+aGrN] = yOff + yAmp * Math.sin(i / aGrN * 2 * Math.PI);
	} else if (curveTyp == 2) {   
	   if (i < aGrN/2) {
	     aXY[i+aGrN] = yOff + yAmp;
	   } else {
	     aXY[i+aGrN] = yOff - yAmp;
	   }
	} else if (curveTyp == 3){  // Triangle
	   if (i < aGrN/4) {
	     aXY[i+aGrN] = yOff + yAmp * i * 4 / aGrN;
	   } else if (i < 3/4*aGrN) {
	     aXY[i+aGrN] = yOff + yAmp - yAmp * (i - aGrN / 4) * 4 / aGrN;
       } else {
	     aXY[i+aGrN] = yOff - yAmp + yAmp * (i - 3/4 * aGrN) * 4 / aGrN;
	   }
	} else {  // Stair
	   if (i < aGrN/10) {
	     aXY[i+aGrN] = yOff - yAmp;
	   } else if (i < 2/10*aGrN) {
	     aXY[i+aGrN] = yOff - yAmp * 3 / 5;
       } else if (i < 3/10*aGrN) {
	     aXY[i+aGrN] = yOff - yAmp * 1 / 5;
       } else if (i < 4/10*aGrN) {
	     aXY[i+aGrN] = yOff + yAmp * 1 / 5;
	   } else if (i < 5/10*aGrN) {
	     aXY[i+aGrN] = yOff + yAmp * 3 / 5;
	   } else if (i < 6/10*aGrN) {
	     aXY[i+aGrN] = yOff + yAmp;
	   } else if (i < 7/10*aGrN) {
	     aXY[i+aGrN] = yOff + yAmp * 3/ 5;
	   } else if (i < 8/10*aGrN) {
	     aXY[i+aGrN] = yOff + yAmp * 1/5;
	   } else if (i < 9/10*aGrN) {
	     aXY[i+aGrN] = yOff - yAmp * 1/5;
	   } else {
	     aXY[i+aGrN] = yOff - yAmp * 3/5;
	   }
    }	
  }
  ScatterPlot("Ausgangssignal","Signal",aXY,aGrN,
		      "time","lin","minmax",
			  "Amplitude","lin","auto","Fine");
   genCmdAWG();
   if (aState == "Run") {
	sendCmd();
   }
}

// window.addEventListener("load",Inputsignal ());

//----------------------------------------------------------------------------------//
//-------------------- Oscilloscope    ---------------------------------------------//
//----------------------------------------------------------------------------------//
var mouseX = 0;

var channels = new Array();
			  
// creates HTML entries for C1, C2, C3, C4, M1
function createChannel(baseId, checked, index, unit) {
   var sel = 1;
	var objTxt  ='<input type="checkbox" id="c' + baseId +'" value="value" ' + checked 
	            + ' onclick="toggleCheck(' + "'" + baseId + "'" + ',' + index + ')">';
	   objTxt += baseId; 
	   if (unit == 1) {
	     objTxt += ' Unit:'; 
	     objTxt += '<select id="unit' + baseId +'" >';
	     // <option value="W" onclick="changeUnitX('AWG1','')">W</option>
         objTxt += '<option value="count" onclick="changeUnitX(' +"'" + baseId + "',''" + ')">Count</option>';
         objTxt += '<option value="V" selected onclick="changeUnitX(' + "'" + baseId + "','V'" +')">V</option>';
         objTxt += '<option value="A" onclick="changeUnitX(' + "'" + baseId + "','A'" + ')">A</option>';
         objTxt += '<option value="O" onclick="changeUnitX(' + "'" + baseId + "','&Omega;'" + ')">&Omega;</option>';
         objTxt += '<option value="W" onclick="changeUnitX(' + "'" + baseId + "','W'" + ')">W</option>';
         objTxt += '</select><br>';
	   }	 
	if (checked == "checked") objTxt += '<table id="tab' + baseId +'" style="display:block"><tr><td>'
	else { 
	  objTxt += '<table id="tab' + baseId +'" style="display:none"><tr><td>';
	  sel = 0;
	}  
	   objTxt += 'Offset: </td><td><input type="text" value="0 V" size="5" id="off' + baseId +'Val" onkeyup="readCRX(e,' + "'off" + baseId + "','s')" + '"></td><td>'; // missing onkeyup 
	   objTxt += '<img id="off' + baseId + 'ValCT" style="display:block" src="ImagesS/SelectListA.png" width="16" height="16"' 
	           + 'onclick="comboBox('+ "'off" + baseId + "','Val','" + 'CB' + "',2,'V')" +'">';
       objTxt += '<div id="off'  + baseId + 'ValCB" style="display:none">';
       objTxt += '<select id="off'  + baseId + 'ValS" onchange="comboBox('+ "'off" + baseId + "','Val','"
		        + 'CT' + "',2,'V')" +'"></select>';
	   objTxt += '</div>';
	   objTxt += '</td></tr>';
	   objTxt += ' <tr><td>Range: </td><td><input type="text" value="1 V/div" size="5" id="range' + baseId + 'Val" onkeyup="readCRX(e,' + "'range" + baseId + "','s')" + '"></td><td>';; // missing onkeyup
	   objTxt += '  <img id="range' + baseId +'ValCT" style="display:block" src="ImagesS/SelectListA.png" width="16" height="16"'
                + 'onclick="comboBox('+ "'range" + baseId + "','Val','" + 'CB' + "',2,'V/div')" +'">';
       objTxt += '<div id="range'  + baseId + 'ValCB" style="display:none">';
       objTxt += '<select id="range'  + baseId + 'ValS" onchange="comboBox('+ "'range" + baseId + "','Val','"
		        + 'CT' + "',2,'V/div')" +'"></select>';
	   objTxt += '</div>';
        objTxt += '  </td></tr>';
		objTxt += '  </table>';
	document.getElementById(baseId).innerHTML = objTxt;	  
    var objChan = {
	           name: baseId,
               selected: sel,
			   unit: "V",
			   offset: 0,
			   range: 1,
			   offsetB: 0,  // Backup offset
			   rangeB: 1,   // Backup range if switched to code
			   factor: 1,
			   offScale: 0,
			   min: 0,
			   max: 0,
			   amplitude: 0,
			   average: 0,
			   frequency: 0,
			   period: 0
              } 
	channels.push(objChan);
	// populate select lists
	var list1 = "";
    for (var i = 0; i < voltRange.length; i++) {
         list1 +='<option value="' + voltRange[i] + '">' + voltRange[i] + '</option>';
    }			 
    document.getElementById("off" + baseId + "ValS").innerHTML = list1;	  
	list1 = "";
    for (var i = 0; i < voltDivRange.length; i++) {
         list1 +='<option value="' + voltDivRange[i] + '">' + voltDivRange[i] + '</option>';
    }			 
    document.getElementById("range" + baseId + "ValS").innerHTML = list1;	  
}		  

// for time id= pos base baseId: Time, range timeRange, timeBaseRange
function addSelectList(id, range, unit) {
	var list1 = "";
    for (var i = 0; i < range.length; i++) {
         list1 +='<option value="' + range[i] + '">' + range[i] + '</option>';
    }			 
    document.getElementById(id + "ValS").innerHTML = list1;	  
}

function addTimeList(){
  addSelectList("pos",timeRange,"s");
  addSelectList("base",timeBaseRange,"s/div");
}

window.addEventListener("load",addTimeList());

function confOsc() {
          var cmdO = "O";
		  // alert(document.getElementById("dataMax").value);
		  dataMax = parseInt(document.getElementById("dataMax").value); // 512: 0200
		  cmdO += decToHex(dataMax,4);           // Block size first
		  if (currUnit == 0) { // code 
		    timeBase = Math.round(unitToValue(document.getElementById("baseVal").value));
		  } else { // time
		    timeBase = Math.round(unitToValue(document.getElementById("baseVal").value)/200E-6);
		  }
		  cmdO += decToHex((timeBase + 1),4);   // Sampling next FPGA 0 and 1 same! 
		  // update command field
		  document.getElementById("cmdTxt").value = cmdO;
		  sendCmdC();                           // send OSC configuration  
		  // update cynchronized sine function
          genCmdAWG();
          if (aState == "Run") {
	        sendCmd();
          }
}

function updateOSC(){
	   // update value field
       updateChanFields();
	   updatePlot();
       confOsc();	   
}

function readCRX(key,id,unit) {
	if (!key) {	key = event; key.which = key.keyCode; }
	if (key.which == 13) { 
       updateOSC();
 	}
}

// Claculate min, max, amplitude, average, frequency and period for channels. 
function chanStats() {
  for (var i = 0; i < channels.length; i++) { // all channels
     var min;
	 if (currUnit == 0) min = dataOSC3[i*dataMax/2];
	 else min = dataOSC2[i*dataMax/2];
     var max = min;
	 var avg = min;
     for (var i1 = 1; i1 < dataMax/2; i1++) {
       var point;
	   if (currUnit == 0) point = dataOSC3[i*dataMax/2 + i1];
       else point = dataOSC2[i*dataMax/2 + i1];	   
	   if ( point < min) min = point; 
	   if ( point > max) max = point; 
	   avg = avg + point;
     }
	 channels[i].min = min;
	 channels[i].max = max;
 	 avg = avg/dataMax*2;
	 channels[i].average = avg;
     channels[i].amplitude = (max - min)/2;
	 // period and frequency
	 var t = new Array;
	 for (var i1 = 1; i1 < dataMax/2; i1++) {
       var point1;
	   if (currUnit == 0) point1 = dataOSC3[i*dataMax/2 + i1];
       else point1 = dataOSC2[i*dataMax/2 + i1]; 	   
	   var point2;
	   if (currUnit == 0) point2 = dataOSC3[i*dataMax/2 + i1 - 1];
       else point2 = dataOSC2[i*dataMax/2 + i1 - 1]; 	   
	   var point3 = point1;
	   if (point1 > point2) { point1 = point2; point2 = point3; }
       if ((point1 <= avg) && (point2 >= avg)) {
	      t.push(i1);
       }	   
     }
	 // Differences between t(i) half period
	 var tx = new Array;
	 for (var i1 = 1; i1 < t.length; i1++) {
	    tx.push(t[i1]-t[i1-1]); 
	 }
	 var periodAvg = 0;
	 for (var i1 = 1; i1 < tx.length; i1++) {
	    periodAvg += (t[i1]-t[i1-1]);  
	 }
	 if (currUnit == 0) periodAvg = periodAvg / (tx.length-1) * (dataOSC3[1] - dataOSC3[0]) * 2;
	 else periodAvg = periodAvg / (tx.length-1) * (dataOSC2[1] - dataOSC2[0]) * 2;
	 channels[i].period = periodAvg;
	 channels[i].frequency = 1/periodAvg;
  }
  var chanTxt = "Measurement <br>\n<table>";
  for (var i = 1; i < channels.length; i++) { // all channels
   if  (channels[i].selected == 1) {
    var xUnit = channels[i].unit;
	var tUnit ="s"; 
	var fUnit="Hz";
	if (currUnit == 0) { xUnit = ""; tUnit=""; fUnit="";}
    chanTxt += "<tr><td class='bo" + i +"'>"; 
	chanTxt += channels[i].name + " Min: " + valueToUnit(channels[i].min)  + xUnit + "<br>"
    chanTxt += channels[i].name + " Max: " + valueToUnit(channels[i].max) + xUnit + "<br>"
    chanTxt += channels[i].name + " Avg: " + valueToUnit(channels[i].average) + xUnit + "<br>"
    chanTxt += channels[i].name + " Amp: " + valueToUnit(channels[i].amplitude) + xUnit + "<br>"
    chanTxt += channels[i].name + " T: " + valueToUnit(channels[i].period) + tUnit +" <br>"
  	chanTxt += channels[i].name + " f: " + valueToUnit(channels[i].frequency) + fUnit + " <br>"
	chanTxt += "</td></tr>";
   }	
  }
  chanTxt += "</table>";
  document.getElementById("measureOSC").innerHTML = chanTxt;
}

function changeUnitX(id,unit) {
  for (var i=0; i < channels.length; i++) {
     if (channels[i].name == id) {
	    channels[i].unit = unit;
		// ToDo: change offset, range list !!
	 }
  }
}

function toggleCheck(id, index){
  var display = document.getElementById("tab"+id).style.display;
  if (display == "block") { 
    document.getElementById("tab"+id).style.display = "none";
    channels[index].selected = 0;
  } else {
    document.getElementById("tab"+id).style.display = "block";
    channels[index].selected = 1;
  }
  updatePlot();
  chanStats()
}

// createChannel("Time","checked",1,0)
var objChan = { name: "time", selected: 1, unit: "s", offset: 0, range: 0.3E-3, offsetB: 0, rangeB: 0.3E-3, factor : 1, offScale: 0 } 
channels.push(objChan);

createChannel("AWG1", "checked",1,0);
createChannel("C1", "checked",2,0);
createChannel("C2", "",3,0);
createChannel("C3", "",4,0);
createChannel("C4", "",5,0);
// createChannel("M1", "",6);
var cList = ["Time","AWG1","C1","C2","C3","C4"];

function updateChanFields() {
  // Time
  channels[0].offset = unitToValue(document.getElementById("posVal").value);
  channels[0].range = unitToValue(document.getElementById("baseVal").value);
  for (var i = 1; i < channels.length; i++) { // no M1 therefore -1 
    channels[i].offset = unitToValue(document.getElementById("off" + cList[i] + "Val").value);
	channels[i].range = unitToValue(document.getElementById("range" + cList[i] + "Val").value);
  }
}

var colorstr = ['#0000ff','#00a000','#ff0000','#ff00ff','#007070','#700070','#ffff00','#00ffff']

function drawGrid(id) {
   var canv_obj=document.getElementById(id);
   
   if (!canv_obj) { alert('Error: I cannot find the canvas element!'); return; }
   if (!canv_obj.getContext) {alert('Error: no canvas.getContext!');return;}
    // Get the 2D canvas context.
   var chart_context = canv_obj.getContext('2d');
   if (!chart_context) { alert('Error: failed to getContext!'); return; }
   chart_context.clearRect(0,0,canv_obj.width,canv_obj.height);
   // Grid
   // 20% are for labels
   var xll = 0.18 * canv_obj.width;
   var xur = (1 -0.18) * canv_obj.width;
   var yll = 0.1 * canv_obj.height;
   var yur = (1 - 0.1)*canv_obj.height;
   chart_context.strokeStyle = "#000000"; // black
   chart_context.beginPath();
   chart_context.rect(xll,yll,xur-xll,yur-yll);
   chart_context.stroke();
   var xstep = Math.round((xur - xll)/10);
   var ystep = Math.round((yur - yll)/10);
   chart_context.lineWidth = 1;
   chart_context.setLineDash([1, 1]);  // dashes are 5px and spaces are 3px
   for (var i = 1; i < 10; i++){  // 10 horizontal
      chart_context.beginPath();
      chart_context.moveTo(xll, yll + i * ystep);
      chart_context.lineTo(xur, yll + i * ystep);
      chart_context.stroke();     
   }   
   for (var i = 1; i < 10; i++){  // 10 horizontal
      chart_context.beginPath();
      chart_context.moveTo(xll + i * xstep, yll);
      chart_context.lineTo(xll + i * xstep, yur);
      chart_context.stroke();     
   }   
   // small marks
    chart_context.setLineDash([]);
   for (var i = 1; i < 100; i++){  // 10 horizontal
      chart_context.beginPath();
      chart_context.moveTo(xll, Math.round((yur - yll)/100 * i + yll));
      chart_context.lineTo(xll + 4, Math.round((yur -yll)/100 * i + yll));
      chart_context.stroke();     
    }      
}

window.addEventListener("load",drawGrid('OSC'));
window.addEventListener("load",drawGrid('fftChart'));

//  
 var currCon = 0;      // current Position of acquisition there the curve starts and ends
 var currUnit = 1;     // Unit voltage or code
 var dataMax = 512;
 var dataOSC1 =[];    // all sorted data
 var dataOSC2 =[];    // final oscilloscope data voltage extracted with trigger 
 var dataOSC3 =[];    // final oscilloscope data code extracted with trigger 
 var xAxisIndex = 0;
 var activeIndex = 1;
 
var mouseStartX = 0;
var mouseStartY = 0;
var mouseCurrX = 0;
var mouseCurrY = 0;
var offsetStart;
var widthX, heightY;
var lines = new Array("pos","offAWG1","offC1","offC2","offC3","offC4","offM1");
var sprites = new Array();  // trigger pos, level, active curve 0, x1, x2 cursor, y1,y2 cursor
// each sprite has: lower left, upper right position; curve color;  type x,x2,y1,y2,filled triangle right, left top, bottom TR,TL,TT, TB
// each sprite has a callback fnction

// Trigger triangle: source, level -> position, color?

function listenCanvas(event) { // event listener for canvas How to add?
      var canv_obj=document.getElementById("OSC");
      var rect = canv_obj.getBoundingClientRect();
      // mouse and touchscreen
      if (mouseX == 1) {   // x - axis right left canvas area? 
        mouseCurrX = Math.round(event.clientX - rect.left);
        mouseCurrY = Math.round(event.clientY - rect.top);
	    channels[xAxisIndex].offset = offsetStart + Math.trunc((mouseCurrX - mouseStartX) / widthX * 100)/10 * channels[xAxisIndex].range;
        document.getElementById("mouse").innerHTML = "Move " + mouseCurrX + "," + mouseCurrY + "," + mouseX;		
	    updatePlot();
		document.getElementById(lines[xAxisIndex]+"Val").value = valueToUnit(channels[xAxisIndex].offset) + channels[xAxisIndex].unit;
		// update range entry!!
      } else if 	(mouseX == 2) { // y axis up down canvas area?
        mouseCurrX = Math.round(event.clientX - rect.left);
        mouseCurrY = Math.round(event.clientY - rect.top);
	    channels[activeIndex].offset = offsetStart - Math.trunc((mouseCurrY - mouseStartY) / heightY * 100) / 10 * channels[activeIndex].range;
        document.getElementById("mouse").innerHTML = "Move " + mouseCurrX + "," + mouseCurrY + "," + mouseX;		
	    updatePlot();
		document.getElementById(lines[activeIndex]+"Val").value = valueToUnit(channels[activeIndex].offset) + channels[activeIndex].unit;
      }
      
      // x1, x2 cursor vertical column canvas area?
      // y1, y2 cursor row canvas area?
      // marker for channels and trigger canvas area?
}

function addCanvasEvent(){
   var canv_obj=document.getElementById("OSC");
   var xll=0.18*canv_obj.width;
   var xur= (0.18+perSizeX)*canv_obj.width;
   widthX = xur - xll;
   var yll=0.1*canv_obj.height;
   var yur=(0.1+perSizeY)*canv_obj.height;
   heightY = yur - yll;
   var xb = canv_obj.width*0.05;
   var yb = canv_obj.height*0.05;
	
   canv_obj.addEventListener('mouseup', function(event){ mouseX = 0;}, false);  // attach event listener to canvas
   canv_obj.addEventListener('mousedown', function(event){ 
        var canv_obj=document.getElementById("OSC");
		var rect = canv_obj.getBoundingClientRect();
		mouseStartX = Math.round(event.clientX - rect.left);
		mouseStartY = Math.round(event.clientY - rect.top);
		// x-axis offset
		if   ((mouseStartX < xur) && (mouseStartX > xll)
          && (mouseStartY < yur + yb) && (mouseStartY > yur)) {
          mouseX = 1;
          offsetStart = channels[xAxisIndex].offset;		  
		} else 
		// y-axis
		if  ((mouseStartX < xll) && (mouseStartX > xll - xb)
          && (mouseStartY < yur) && (mouseStartY > yll)) {
          mouseX = 2; 
          offsetStart = channels[activeIndex].offset;		  
		} 		
        // x1,x2,y1,y2 cursor
        // awg1, c1, c2,c3,c4, xaxis, level triangle 
        document.getElementById("mouse").innerHTML = "Down " + mouseStartX + "," + mouseStartY + "," + mouseX;		
	  }, false
   );  // attach event listener to canvas
   canv_obj.addEventListener('mousemove', listenCanvas, false);  // attach event listener to canvas
   // touchstart, touchmove, touchend   
   // alert("Events registered");
}

window.addEventListener("load",addCanvasEvent());

function activeChan(x) {
  activeIndex = x;
  if (channels[x].selected == 0) { channels[x].selected = 1; } // make active
  updatePlot();
}

function changeXAxis() {
   xAxisIndex = document.getElementById("xyAxis").value; 
   // if (channels[xAxisIndex].selected == 0) { channels[xAxisIndex].selected = 1; } // make active
   updatePlot();
}

function updatePlot(){
   if (currUnit == 0) {  // code
      ScatterPlotO("OSC","Oszilloskop",dataOSC3,dataMax/2,
		                     "time","linO","Minmax",
			                 "Amplitude","linO","auto","Grid",
							 xAxisIndex, activeIndex, channels);
   } else {  // voltage
      ScatterPlotO("OSC","Oszilloskop",dataOSC2,dataMax/2,
		                     "time","linO","Minmax",
			                 "Amplitude","linO","auto","Grid",
							 xAxisIndex, activeIndex, channels);
   }
}

function saveData() {
    var tabTxt ="<span style='background-color:#cce6ff;' onclick='document.getElementById(" + '"dataXY"' + ').style.display = ' + '"none";' + "'> Hide </span><br> <table>";
    var dataMax2= dataMax/2;
    // check for active channels
	var cAWG1 = document.getElementById("cAWG1").checked;
	var cC1 = document.getElementById("cC1").checked;
	var cC2 = document.getElementById("cC2").checked;
	var cC3 = document.getElementById("cC3").checked;
	var cC4 = document.getElementById("cC4").checked;
    // Lables
	   tabTxt += "<tr>";
	   tabTxt += "<td> time / s </td>"; 
	   if (cAWG1) { tabTxt += "<td> AWG1 / V</td>"; }
	   if (cC1) { tabTxt += "<td> OSC1 / V</td>"; }
	   if (cC2) { tabTxt += "<td> OSC2 / V</td>"; }
	   if (cC3) { tabTxt += "<td> OSC3 / V</td>"; }
	   if (cC4) { tabTxt += "<td> OSC4 / V</td>"; }
	   tabTxt += "<td> time code</td>"; 
	   if (cAWG1) { tabTxt += "<td> AWG1 code </td>"; }
	   if (cC1) { tabTxt += "<td> OSC1 code</td>"; }
	   if (cC2) { tabTxt += "<td> OSC2 code</td>"; }
	   if (cC3) { tabTxt += "<td> OSC3 code</td>"; }
	   if (cC4) { tabTxt += "<td> OSC4 code</td>"; }
	   tabTxt += "</tr>"; 
    // values
	for (var i = 0; i < dataMax/2; i++) {
	   tabTxt += "<tr>";
	   tabTxt += "<td>" + dataOSC2[i].toPrecision(6) + "</td>"; 
	   if (cAWG1) { tabTxt += "<td>" + dataOSC2[i + dataMax2].toPrecision(6) + "</td>"; }
	   if (cC1) { tabTxt += "<td>" + dataOSC2[i + 2 * dataMax2].toPrecision(6) + "</td>"; }
	   if (cC2) { tabTxt += "<td>" + dataOSC2[i + 3 * dataMax2].toPrecision(6) + "</td>"; }
	   if (cC3) { tabTxt += "<td>" + dataOSC2[i + 4 * dataMax2].toPrecision(6) + "</td>"; }
	   if (cC4) { tabTxt += "<td>" + dataOSC2[i + 5 * dataMax2].toPrecision(6) + "</td>"; }
	   tabTxt += "<td>" + dataOSC3[i] + "</td>"; 
	   if (cAWG1) { tabTxt += "<td>" + dataOSC3[i + dataMax2] + "</td>"; }
	   if (cC1) { tabTxt += "<td>" + dataOSC3[i + 2 * dataMax2] + "</td>"; }
	   if (cC2) { tabTxt += "<td>" + dataOSC3[i + 3 * dataMax2] + "</td>"; }
	   if (cC3) { tabTxt += "<td>" + dataOSC3[i + 4 * dataMax2] + "</td>"; }
	   if (cC4) { tabTxt += "<td>" + dataOSC3[i + 5 * dataMax2] + "</td>"; }
	   tabTxt += "</tr>"; 
	}
	   tabTxt += "</table>"; 
	document.getElementById("dataXY").innerHTML = tabTxt; 
    document.getElementById("dataXY").style.display = "block";
}

var awgData = new Array();

function generateData() {
    dataMax = parseInt(document.getElementById("dataMax").value); // 512: 0200
    var dataMax2 = dataMax/2;
    genAWGData();
	
    var factor = 1/(4*16*1024-1); // 1 V range XADC, 64k range
    var offset = 0;
    var timeSampling = unitToValue(document.getElementById("timeSampling").value);
    var timestep = timeSampling * (timeBase + 0);     // XADC 10ns * 8 * 104 cycles conversion +1?
    var dataMax2 = Math.round(dataMax/2);
    for (var i = 0; i < dataMax2; i++) {
       // data OSC2 real voltage values
       // dataOSC2[i] = (i - dataMax/4) / 1E6 * 8 ; // maximum acquistion rate trigger center
       dataOSC2[i] = (i - dataMax/4) * timestep ; // maximum acquistion rate trigger center
       dataOSC2[i + dataMax2] = awgData[i] / 64 / 64 / 256 * 3.3;
       dataOSC2[i + 2 * dataMax2] = 3.3 * (1+Math.sin(i*2*Math.PI/dataMax2));
       dataOSC2[i + 3 * dataMax2] = 1.7 * Math.round((1+Math.sin(i*2*Math.PI/dataMax2)) * 128 ) / 128 ;
       dataOSC2[i + 4 * dataMax2] = 1.0 * Math.round((1+Math.sin(5*i*2*Math.PI/dataMax2)) * 2048) / 2048;
       dataOSC2[i + 5 * dataMax2] = 0.5 * Math.round((1+Math.sin(3*i*2*Math.PI/dataMax2)) * 1024 *1024) / 1024/1024;
	   // data OSC3 code values
	   dataOSC3[i] = i;
       dataOSC3[i + dataMax2] = awgData[i];
       dataOSC3[i + 2 * dataMax2] = Math.round((1+Math.sin(i*2*Math.PI/dataMax2))*64);
       dataOSC3[i + 3 * dataMax2] = Math.round((1+Math.sin(i*2*Math.PI/dataMax2)) * 128 );
       dataOSC3[i + 4 * dataMax2] = Math.round((1+Math.sin(5*i*2*Math.PI/dataMax2)) * 2048);
       dataOSC3[i + 5 * dataMax2] = Math.round((1+Math.sin(3*i*2*Math.PI/dataMax2)) * 64 *1024);
    }
    updatePlot();
	let now = new Date();
    let nowTxt = now.getFullYear() + "/" + (now.getMonth()+1)
               + "/" + now.getDate() + " " + now.getHours()
	     	   + ":" + now.getMinutes() + ":" + now.getSeconds()+ "." + now.getMilliseconds();			
				// 1 Msps 8 samples per point 1E6/8						
	document.getElementById("statusOSC").innerHTML = "Data generated at " + nowTxt + " " + dataMax2 
				   + " samples" ;
    chanStats();
	// generateFFT();
}

//-------------------------------------------------------------------------
//   Simulate AWG
//-------------------------------------------------------------------------

function genAWGData() {
  dataMax = parseInt(document.getElementById("dataMax").value); // 512: 0200
  var dataMax2 = dataMax/2;
  // var timeSampling = unitToValue(document.getElementById("timeSampling").value);
  // var timestep = timeSampling * (timeBase + 1);     // XADC 10ns * 8 * 104 cycles conversion
				 
  var cmd =	document.getElementById("cmd").innerHTML;
  // triangle or sine
  awgData = [];
  if (cmd[0] == "T" ) { // triangle
    var start = hexToDec(cmd.substring(1,5));  // 16 Bit
	var stop = hexToDec(cmd.substring(5,9));   // 16 Bit
	var step = hexToDec(cmd.substring(9,13));   // 16 Bit
	var repeat = hexToDec(cmd.substring(13,21)); // 32 Bit
	if (repeat < 1) { repeat = 1; }
	// alert(start + "," + step + "," + stop + "," + repeat);
	// T26C9745C4D930000C350
	//  starstopstep
	// 9929,19859,29788,50000
    var valAWG = start;
	var edge = 1;  // rising 1 falling -1
	// 820 = 1/(1MSps/8 (fADC))/10ns (fFPGA fCalc)
    // Number of steps: dataMax2 * timeBase * 820
	var sampleIndex = 0;
	for (var i = 0; i < dataMax2 * timeBase * 820; i++) {
      if ( i % repeat == 0 ) { // enable in FPGA
        valAWG = valAWG + step * edge;                 // operating on 32 BIt values??
        if  ((edge > 0) & (valAWG > stop)) { //rising
		   valAWG = stop - (valAWG - stop); 
		   edge = -1;
        } else 
	    if ((edge < 0) & (valAWG < start)) { // falling		 
		   valAWG = start + (start - valAWG); 
		   edge = 1;
        }	
	  }
      if (i % (820 * timeBase) == 0 ) {  // save sampled data
	      awgData[sampleIndex] = valAWG * 32;
		  sampleIndex ++;
      }	  
	}	
  } else if (cmd[0] == "S" ) {  // sine 32 Bit calculation
    var step = timeBase * hexToDec(cmd.substring(1,9)) * 256;      // angle for +- 1ms, 512 samples 
    var amplitude = hexToDec(cmd.substring(9,17));  
	var offset = hexToDec(cmd.substring(17,25));
	// alert(cmd + "," + step + "," + amplitude + "," + offset + "," + cmd.substring(17,26));
    var scaleMax = 64 * 1024;  // resolution
	var dRe = Math.cos(step/(64*64*1024*1024) * 2 * Math.PI ) ;
	var dIm  = Math.sin(step/(64*64*1024*1024) * 2 * Math.PI );
	var xRe = amplitude;
	var xIm = 0;
	var xRe1;
	var xIm1;
	for (var i = 0; i < dataMax2; i++) {
        awgData [i] = Math.trunc(xRe / 1024 / 2 + offset / 1024 / 2);
   	    xRe1 = Math.trunc( (xRe * dRe) * scaleMax  ) / scaleMax // next step calculation
	         - Math.trunc( (xIm * dIm) * scaleMax  ) / scaleMax; // next step calculation
		xIm1 = Math.trunc( (xRe * dIm ) * scaleMax  ) / scaleMax //  rounded by scaleMax
		     + Math.trunc( (xIm * dRe) * scaleMax  ) / scaleMax; //  rounded by scaleMax
		xRe = xRe1; xIm = xIm1;                                              // update value
	}
  } else {  // ramp
	for (var i = 0; i < dataMax2; i++) {
        awgData [i] = i * 1024;
	}
  }  
}

// changes between voltage and code
// 

function changeUnit() {
  // set currUnit
  currUnit = document.getElementById("currUnit").value;
  // strategy changing unit save old scaling activate new scaling
  if (currUnit == 0) {  // code 
	// set time
		addSelectList("pos", codePos, "");
		addSelectList("base", codeRange, "");
		channels[0].rangeB = channels[0].range;
		channels[0].offsetB = channels[0].offset;
		document.getElementById("posVal").value = "-" + dataMax/4;
		document.getElementById("baseVal").value = dataMax/16;
	    // all channels restore rangeVal and offVal 
		for (var j = 1; j < channels.length; j++) {
		    addSelectList("range" + channels[j].name, codeRange, "");
		    addSelectList("off" + channels[j].name, codeRange, "");
			channels[j].rangeB = channels[j].range;
			channels[j].offsetB = channels[j].offset;
			channels[j].range = 512*16; // 
			channels[j].offset = -256*16*8; //
			document.getElementById("range" + channels[j].name +"Val").value = channels[j].range;
			document.getElementById("off" + channels[j].name +"Val").value = channels[j].offset;
		}
  } else {   // activate voltage time 
    // set time 
		addSelectList("pos", timeRange, "s");
		addSelectList("base", timeBaseRange, "s");
	    // all channels restore rangeVal and offVal 
		document.getElementById("posVal").value = valueToUnit(channels[0].offsetB) + "s";
		document.getElementById("baseVal").value = valueToUnit(channels[0].rangeB) + "s";
		for (var j = 1; j < channels.length; j++) {
		    addSelectList("range" + channels[j].name, voltRange, "V");
		    addSelectList("off" + channels[j].name, voltRange, "V");
			channels[j].range = channels[j].rangeB;                   // get original range, offset from backup B
			channels[j].offset = channels[j].offsetB;
			document.getElementById("range" + channels[j].name +"Val").value = valueToUnit(channels[j].range) + " V";
			document.getElementById("off" + channels[j].name +"Val").value = valueToUnit(channels[j].offset) + " V";
		}
  }     
  // update
  chanStats()
  updateOSC();
}

//----------------------------------------------------------------------------------//
//-------------------- FFT ---------------------------------------------------------//
// based on ADCharacteristic.html --------------------------------------------------//
//----------------------------------------------------------------------------------//
	    function nextPwrOf2(n) {
         var m = -1;
		 var two = 1;
         for (m = 2; m < 16; m++) {
           two = two * 2;
		   if (n < two) return two/2;
		 }
         return -1;
        }

	  function nutall(nPair) { // nutall window
	  var s = new Array();
	  var a0 = 0.3635819;
	  var a1 = 0.4891775;
	  var a2 = 0.1365995;
	  var a3 = 0.0106411;
	  for (var i = 0; i < nPair; i++) {
	     s[i] = a0 - a1 * Math.cos(2*Math.PI*i/nPair) 
		      + a2 * Math.cos(4*Math.PI*i/nPair)
              - a3 * Math.cos(6*Math.PI*i/nPair);
	  }
	  return s;
	  }
	  
      function blackman(nPair) { // blackman window
	  var s = new Array();
	  var a0 = 0.35875;
	  var a1 = 0.48829;
	  var a2 = 0.14128;
	  var a3 = 0.01168;
	  for (var i = 0; i < nPair; i++) {
	     s[i] = a0 - a1 * Math.cos(2*Math.PI*i/(nPair-1)) 
		      + a2 * Math.cos(4*Math.PI*i/(nPair-1))
              - a3 * Math.cos(6*Math.PI*i/(nPair-1));
	  }
	  return s;
	  }

      function hamming(nPair) {
	  var s = new Array();
	  for (var i = 0; i < nPair; i++) {
	     s[i] = 0.54 
		      + 0.46 * Math.cos(2 * Math.PI * (i -nPair / 2 )/ nPair);
	  }
	  return s;
	  }

function calcHarmonics() {
   // which channel
   var actChan = document.getElementById("fftSrc").value;   
   var gr1 = Math.round(nPair / 2) - 1;
   var betragA = [];
   // transfer data to FFT array
    // Calculate signal to noise for first 10 peaks
	// sort Betrag ascending and find signal (largest betrag)
   	var j = parseInt(actChan);   // activeIndex -1 one list only
	var sig = 0;
	var signal = betrag[0 + gr1 * j];
	for(var i = 0; i < gr1; i++)  // transfer to object array
      {
        var timeSampling = unitToValue(document.getElementById("timeSampling").value);
	    var timestep = timeSampling * (timeBase + 1);     // XADC 10ns * 8 * 104 cycles conversion
        if (currUnit == 0) timestep = 1 / nPair;
	    var objx = {
		             key: betrag[i + gr1 * j], // square of magnitude
					 index: i,
		             freq: (i + 1) / timestep / nPair       // scaled with acquistion time 8 cycle2 1MSps, 256 samples
		};
		if (objx.key > signal) { 
		    sig = objx.index;
			signal = objx.key;
		}
		betragA.push(objx);
      }
	   
	   betragA.sort(function(a,b){ return b.key - a.key});
	   
	   var snrText = "";
	   var noiseA = 0;
	   var maxLength = 10; 
	   for(i = maxLength + 1; i < gr1; i++) // calculate remaining noise without signal
       {
	     if (betragA[i].index != sig) { // not signal
	        noiseA += betragA[i].key; // sum of squares total noise of rest
	     }		
	   }
	   var totalNoise = Math.round(20 * Math.log(Math.sqrt(noiseA))/Math.LN10 * 100)/100;
	   for(i = 0; i < maxLength + 1; i++)
       {
	     snrText = "<tr><td class='bo'>" + (betragA[maxLength - i].index + 1) +"</td><td class='bo'>" 
		           + valueToUnit(betragA[maxLength - i].freq) + "</td><td class='bo'>" // frequency 
		           + Math.round(20 * Math.log(Math.sqrt(betragA[maxLength - i].key))/Math.LN10*100)/100 + "</td><td class='bo'>" // signal
		           + Math.round(20 * Math.log(Math.sqrt(noiseA))/Math.LN10 * 100)/100
				   + "</td></tr>" + snrText;
	     noiseA += betragA[maxLength - i].key; // sum of squares				   
	   }
	   var unitX= "in Hz";
	   if (currUnit == 0) unitX = "";
	   snrText = "<table><tr><td>Magnitude List Channel: </td><td class='bo" + actChan + "'>" + cList[actChan] + "</td></tr></table><br>" +
	             "<table border='1'>" +
	             "<tr><td class='bo'>Index</td><td class='bo'>f " + unitX +"</td>" +
	             "<td class='bo'> signal<br> magnitude<br> dB</td>" +
	             "<td class='bo'> Total<br> noise<br> magnitude<br> dB </td></tr>"+ snrText + "</table>";
       document.getElementById('fftList').innerHTML = snrText;
}

   var nPair = 256;
   var betrag =[];

function generateFFT() {
   // which channel
   var actChan = document.getElementById("fftSrc").value;
   // transfer data to FFT array
   var ind = +1; // +1 forward fft -1 reverse fft
   var aR = [];  // real values 
   var aI = [];  // new Array() imaginary values
   var betragdB = [];
   var betragA = [];
   var channelsA =[];
   var maxG = 0;
   var minG = 1;
   var first = 0;

   currUnit = document.getElementById("currUnit").value;
   nPair = dataMax/2;
   
   for (var j = 0; j < channels.length; j++) { // all channels
	 channelsA[j] = Object.assign({}, channels[j]);
   }
   // start FFT
  for (var j = 0; j < 5; j++) { // all channels
   
   for (var i = 0; i < nPair; i++) {
      // aR[i] = dataOSC2[i + actChan * nPair];
      if (currUnit == 0) {  // code 
	     aR[i] = dataOSC3[i + (j + 1) * nPair];
	  } else {              // voltage, time
	     aR[i] = dataOSC2[i + (j + 1) * nPair];
	  }
	  aI[i] = 0;
   }
   fft(ind, nPair, aR, aI);  //  FFT
  
   // Calculate Magnitude
   var gr1 = Math.round(nPair / 2) - 1;
   for(var i = 0; i < gr1; i++) {   // all buckets, no DC
     var timeSampling = unitToValue(document.getElementById("timeSampling").value);
	 var timestep = timeSampling * (timeBase + 1);     // XADC 10ns * 8 * 104 cycles conversion
	 if (currUnit == 0) timestep = 1 / nPair;
	 //	 var timestep = 8.32E-6;
	 betragdB[i] = (i + 1) / timestep / nPair;           // scaled with acquistion time 8 cycle2 1MSps, 256 samples
	 betrag[i] = (i + 1) / timestep / nPair;
	 betrag[i + gr1 * (j + 1)] = 2 * (aR[i + 1] * aR[i + 1] + aI[i + 1] * aI[i + 1]);
     // alert(i + "," + gr1 + "," + j + "," + betrag[i + gr1 * (j + 1)]);
   }	 
		
   // fix betrag = 0 for log operation
   var min = betrag[0 + gr1 * (j + 1)];
   var max = betrag[0 + gr1 * (j + 1)];
	if ((channelsA[j].selected == 1)  && (first == 0))  { // should be done once
	  first = 1;
	  minG = min;
	  maxG = max;
	}  
   for(var i = 1; i < gr1; i++) {   
	 if ((betrag[i + gr1 * (j + 1)] < min) && (betrag[i + gr1 * (j + 1)] > 0)) { // prepare betrag = 0 for log operation 
	   min = betrag[i + gr1 * (j + 1)];
	 }
	 if ((betrag[i + gr1 * (j + 1)] > max)) max = betrag[i + gr1 * (j + 1)];
	 if ((betrag[i + gr1 * (j + 1)] < 0)) alert("negativ");
   }
   // alert(min + "," + (10 * Math.log(min) / Math.LN10));
   // Convert to dB 
   for(var i = 0; i < gr1; i++) {   // all buckets, no DC
     if (betrag[i + gr1 * (j + 1)] == 0) {
		  betragdB[i + gr1 * (j + 1)] = 10 * Math.log(min) / Math.LN10; // 10 because of sqrt;
	 } else { 
		   betragdB[i + gr1 * (j + 1)] = 10 * Math.log(betrag[i + gr1 * (j + 1)]) / Math.LN10; // 10 because of sqrt
	 }
    }
	if (channelsA[j].selected == 1){
	  if (min < minG) { minG = min; }
	  if (max > maxG) { maxG = max; }
	}  
   }
   // set y axis
   // alert("0 Max:" + maxG + ", Min:" + minG + "x");
   if (maxG == 0) maxG = minG;
   if (minG == 0) minG = maxG/1E5; // range 50 dB
   maxG = 10 * Math.log(maxG) / Math.LN10;
   minG = 10 * Math.log(minG) / Math.LN10;
   // alert("1 Max:" + maxG + ", Min:" + minG + "x");
   scale_lin_max_min (maxG,minG,"auto0");
   maxG = oMax;
   minG = oMin;
   // alert("2 Max:" + maxG + ", Min:" + minG + "x" + oMax);
   var range = (maxG - minG) / 10;
   // range = 20;  // set fixed range from 10 to -190
   var offset = - (maxG + minG) / 2;
   // offset = 90; // set fixed offset from 10 to -190
   // alert("Range " + range + " offset: " + offset); 
  for (var j = 1; j < channelsA.length; j++) { // all channels, not AWG?
    channelsA[j].range = range;
    channelsA[j].offset = offset;
   }

   // alert(0 + "," + 127 + "," + 3 + "," + betrag[0 + 127 * (3 + 1)]);
   // Graphics
   // FFT Chart
	ScatterPlotO("fftChart",(gr1 + " FFT points of " + (2 * gr1 + 2 ) + " data points"),betragdB,gr1,
	              "Frequency","log","auto",
				  "Magnitude [dB]","linO","auto0","Grid"  //"Grid"/"Fine"
				  ,0, activeIndex, channelsA
				 );
				 
	calcHarmonics(); // update List   
}

//----------------------------------------------------------------------------------//
//-------------------- Histogram ---------------------------------------------//
//----------------------------------------------------------------------------------//
var histo = [];

function createBinBox() { 
                 // text            id      list     Unit slider? 
   var codeRangeLim =[];
    for (var j = 0; j < 5; j++) { // all channels
	   codeRangeLim[j] = codeRange[j];
    }
   
   createComboBox("Number of Bins","bins",codeRangeLim,"",3);
}

function selectBinBox() { 
	document.getElementById("binsValS").value = codeRange[3]; 
}

window.addEventListener("load",createBinBox());
window.addEventListener("load",selectBinBox());


function generateHisto(){
    var dataMax2 = Math.round(dataMax/2); // number of points
	var step = [];
    var dataBins = [];
    var channelsA =[];
    var valTable ="<table><tr><td>Channel</td><td>Min</td><td>Bin Step</td><td>Max</td></tr>";
	var nrBins = document.getElementById("binsVal").value;
		
    for (var j = 0; j < channels.length; j++) { // all channels
	   channelsA[j] = Object.assign({}, channels[j]);
    }
	channelsA[0].offset = - (nrBins-1)/2;
	channelsA[0].range = (nrBins-1)/10;
	
	// get number of bins
    // alert(nrBins);
	var unitX = "V";
	if (currUnit == 0) unitX ="";
	for (var i = 1; i < channels.length; i++) {
     step[i] = (channels[i].max - channels[i].min)/(nrBins-1); // if zero all in bin zero
	 if (channels[i].selected == 1) {
	   valTable +="<tr class='bo" + i + "'><td class='bo" + i + "'>" + channels[i].name + "</td><td>" + valueToUnit(channels[i].min) 
	             + unitX + "</td><td>" + valueToUnit(step[i]) + unitX +"</td><td>" + valueToUnit(channels[i].max) + unitX + "</td></tr>"
	 }
	}
	valTable +="</table>";
	document.getElementById("binsTab").innerHTML = valTable;
	for (var i = 0; i < nrBins; i++) { 	// prefill histo
	  dataBins[i] = i;
	  for (var j = 1; j < 6; j++) { 	// all channels
	  	  dataBins[i + j * nrBins] = 0;
	  }	  
	}
	// fill histo
	// alert(dataMax2);
	for (var i = 0; i < dataMax2; i++) {
	  for (var j = 1; j < 6; j++) { 	// all channels
	  	  var index = Math.round((dataOSC2[i+j*dataMax2] - channels[j].min)/step[j]);
		  if (currUnit == 0) index = Math.round((dataOSC3[i+j*dataMax2] - channels[j].min)/step[j]);
		  dataBins[index + j * nrBins] += 1; // add to bucket
	  }	  
	}
    let now = new Date();
    let nowTxt = now.getFullYear() + "/" + (now.getMonth()+1)
                   + "/" + now.getDate() + " " + now.getHours()
				   + ":" + now.getMinutes() + ":" + now.getSeconds()+ "." + now.getMilliseconds();			
		nowTxt += "Histogram from " + dataMax2 + " points generated at " + nowTxt;

	// generate chart
    ScatterPlotO("histoChart",nowTxt,dataBins,nrBins,
	              "Bins","lin","minmax",
				  "occurence","lin","minmax","Grid"  //Grid
				  ,0, activeIndex, channelsA   // axis proper scaling difficult
				 );
}

window.addEventListener("load",generateData());

//----------------------------------------------------------------------------------//
//-------------------- Ramp Test INL and DNL ---------------------------------------//
//----------------------------------------------------------------------------------//

var finshed = true;
var oscObj = [];
var offsetStart = 0;
var runs = 1;
var runX = 1;
var realRampStep = 0;

function generateRamp() { // start Ramp
   oscObj = [];           // Empty data object
   offsetStart = 0;
   runX = 1;
   generateRampX();
}

function generateRampX() {
  var stepCode = Math.trunc(parseInt(document.getElementById("codesStep").value));  // number of code values
  if (stepCode <= 0) { stepCode = 1; }
  var startCode = parseInt(document.getElementById("codesStart").value) + offsetStart;  // number of code values
  var endCode = Math.trunc(parseInt(document.getElementById("codesEnd").value) / 2) ;  // number of code values
  // Check how many points necessary > 4k?
  runs = Math.trunc(((endCode - startCode)/stepCode) / 1024 ) + 1;  // How many 4k blocks 4 samples each 
  realRampStep = stepCode; 
  stepCode = stepCode * runs;

  document.getElementById("inlResult").innerHTML = "<img src='../ImagesS/1LBN.gif' width='32' height='32'>" 
                                                    + " Measurement ongoing. Run " + runX + " of " + (runs + 1); 
  runX = runX + 1;
  
  endCode = Math.trunc((endCode - startCode)/stepCode) * stepCode + startCode; // Ramp codes down = up
  
  offsetStart = offsetStart + realRampStep;  // for next data set
 
    // Make triangle waveform
    // Repeat 832 because DAC 100MHz, ADC 8.32us
    cmdText = "T" + decToHex(startCode,4) + decToHex(endCode,4)
                  + decToHex(stepCode,4) + decToHex((4*832),8);    // 832, 416,208  4 samples 4*832    
    // sendCmd "T"
    document.getElementById("cmd").innerHTML = cmdText;
    sendCmd();
    // Configure oscilloscope with highest sample rate and 8k buffer
    document.getElementById("dataMax").value = 8192;
    cmdText ="O20000001";         
    // sendCmd "O"
    document.getElementById("cmd").innerHTML = cmdText;
    sendCmd();
    // sendCmd "U" acquiring data
    document.getElementById("cmd").innerHTML = "U";
    sendCmd();
    finished = false;
}

function nextRamp() {
  var dataMax2 = Math.round(dataMax/2);
  // Selected channel 
  var rampSrc = parseInt(document.getElementById("rampSrc").value);  // number of code values

	// make object array with values
      for (var i = 0; i < dataMax2; i++) {              // number of codes loop  
        var point = {  
		  codeAWG : dataOSC3[i +   1 * dataMax2],           // AWG code
          codeOSC : dataOSC3[i +  rampSrc * dataMax2],  // all channels
          codeOSC1 : dataOSC3[i +  2 * dataMax2],  // all channels
          codeOSC2 : dataOSC3[i +  3 * dataMax2],  // all channels
          codeOSC3 : dataOSC3[i +  4 * dataMax2],  // all channels
          codeOSC4 : dataOSC3[i +  5 * dataMax2]  // all channels

	    }
		oscObj.push(point);
	  }	  
  
    // check if finished
  if (offsetStart >= 16) {
    finished = true;
    document.getElementById("rStop").style.display="none";
    document.getElementById("rRun").style.display="block";
    rState="Stop";
    ramp();
  } else { // sent ramp command and acquire next block of data
    generateRampX()
  }
}

// Function ramp()
function ramp() {
    var avgVal = [];
	var idealVal =[];
	var dataINL = [];
	var dataDNL = [];
    var nrCodes;  // number of code values
    var dataMax2 = Math.round(dataMax/2);

	// Selected channel 
    var rampSrc = parseInt(document.getElementById("rampSrc").value);  // number of code values

	for (var j = 0; j < oscObj.length; j++) { 	   // Copy correc5t channel to codeOSC
       if (rampSrc == 1) oscObj[j].codeOSC = oscObj[j].codeAWG;
       if (rampSrc == 2) oscObj[j].codeOSC = oscObj[j].codeOSC1;
       if (rampSrc == 3) oscObj[j].codeOSC = oscObj[j].codeOSC2;
       if (rampSrc == 4) oscObj[j].codeOSC = oscObj[j].codeOSC3;
       if (rampSrc == 5) oscObj[j].codeOSC = oscObj[j].codeOSC4;
	}
	
	// sort oscObj for averaging
    oscObj.sort(function(a,b) { // sort for codeAWG
         if ( a.codeAWG < b.codeAWG )
             return -1;
         if ( a.codeAWG > b.codeAWG )
             return 1;
         return 0;
    });
	
    var samplesX = oscObj.length;     	
	
      for (var i = 0; i < samplesX; i++) {              // number of codes loop  
		avgVal[i] = i;                                          // integer position
		avgVal[i + samplesX] = oscObj[i].codeAWG;         // AWG1
		avgVal[i + 2 * samplesX] = oscObj[i].codeOSC; //
	  }	  
	
    var oscObjAvg = [];
    var codeAWGNow = oscObj[0].codeAWG; 
	oscObjAvg[0] = { 
	    codeAWG : oscObj[0].codeAWG,
	    codeOSC : oscObj[0].codeOSC,
		n : 1
	}
	var nAvg = 0;
	for (var j = 1; j < oscObj.length; j++) { 	   // Averaging
        if (oscObj[j].codeAWG == codeAWGNow) {
		   oscObjAvg[nAvg].codeOSC += oscObj[j].codeOSC;
           oscObjAvg[nAvg].n += 1;		   
		} else {
		  var pointX = {
	         codeAWG : oscObj[j].codeAWG,
	         codeOSC : oscObj[j].codeOSC,
		     n : 1
		  }
		  codeAWGNow = oscObj[j].codeAWG;
		  oscObjAvg.push(pointX);
		  nAvg = nAvg + 1;
		}
	}
	nrCodes = oscObjAvg.length; // Number of unique codes
	for (var j = 0; j < nrCodes; j++) { 	   // Averaging
	  oscObjAvg[j].codeOSC = oscObjAvg[j].codeOSC / oscObjAvg[j].n;
	}
	// min, max OSC AWG
	var minAWG = oscObjAvg[0].codeAWG;
	var maxAWG = oscObjAvg[0].codeAWG;
	var minOSC = oscObjAvg[0].codeOSC;
	var maxOSC = oscObjAvg[0].codeOSC;
	for (var j = 1; j < nrCodes; j++) { 	   // Averaging
	  if (oscObjAvg[j].codeOSC < minOSC) minOSC = oscObjAvg[j].codeOSC;
	  if (oscObjAvg[j].codeOSC > maxOSC) maxOSC = oscObjAvg[j].codeOSC;
	  if (oscObjAvg[j].codeAWG < minAWG) minAWG = oscObjAvg[j].codeAWG;
	  if (oscObjAvg[j].codeAWG > maxAWG) maxAWG = oscObjAvg[j].codeAWG;
	}
	var rangeAWG = maxAWG - minAWG;
	var rangeOSC = maxOSC - minOSC;
	var bins = nrCodes;
    var lsb = rangeOSC / (nrCodes-1);
	// alert(lsb);
	
	// make array with ideal values
    for (var j = 0; j < nrCodes; j++) { 	            // set codes in avgVal
      idealVal[j] = minOSC + (oscObjAvg[j].codeAWG - minAWG) * rangeOSC/rangeAWG;
	  dataINL[j] = oscObjAvg[j].codeAWG;                // x -axis INL
	  dataDNL[j] = oscObjAvg[j].codeAWG;                // x - axis DNL
	}
    
    var inlMin = 0;
    var inlMax = 0;
    var dnlMin = 0;
    var dnlMax = 0;
	dataINL[nrCodes] = 0; // INL
    dataDNL[nrCodes] = 0; // DNL
    for (var i = 1; i < nrCodes; i++) {              // number of codes loop  
        var inlX = (oscObjAvg[i].codeOSC - idealVal[i])/lsb;
		var dnlX = (oscObjAvg[i].codeOSC - oscObjAvg[i-1].codeOSC - lsb)/lsb;
		dataINL[nrCodes + i] = inlX; // INL
        dataDNL[nrCodes + i] = dnlX; // DNL
		if (inlX > inlMax) inlMax = inlX;
		if (inlX < inlMin) inlMin = inlX;
		if (dnlX > dnlMax) dnlMax = dnlX;
		if (dnlX < dnlMin) dnlMin = dnlX;
	}

    document.getElementById("inlResult").innerHTML = "INL " + inlMin.toPrecision(3) 
	   + ".." + inlMax.toPrecision(3) + " DNL " + dnlMin.toPrecision(3) + ".." + dnlMax.toPrecision(3);
   
    let now = new Date();
    let nowTxt = now.getFullYear() + "/" + (now.getMonth()+1)
                   + "/" + now.getDate() + " " + now.getHours()
				   + ":" + now.getMinutes() + ":" + now.getSeconds()+ "." + now.getMilliseconds();			
		nowTxt += " INL DNL from " + (samplesX) + " points generated from " 
		          + oscObjAvg[0].codeAWG + " to " + oscObjAvg[nrCodes-1].codeAWG + " in " + nrCodes + " steps";

    // alert(activeIndex);
	
	// generate chart
	// avgVal,nrCodes
	// dataINLDNL,nrCodes
    ScatterPlot("inlChart",nowTxt,dataINL,nrCodes,
	              "Code","lin","minmax",
				  "INL","lin","auto","Grid"  //Grid
				 );
    ScatterPlot("dnlChart",nowTxt,dataDNL,nrCodes,
	              "Code","lin","minmax",
				  "DNL","lin","auto","Grid"  //Grid
				 );
    // show data for one channel: code, real, ideal, INL, DNL
    // setLegend("Real,Ideal,INL,DNL");
    ScatterPlotX("rampChart",nowTxt,avgVal,samplesX,
	              "Code","lin","minmax",
				  "Value, INL, DNL","lin","minmax","Fine"  //Grid
				 );
  // Make a lookup table (lookupList) with this data (oscObjAvg)

	// sort oscObjAvg with OSC codes
    oscObjAvg.sort(function(a,b) { // sort for codeAWG
         if ( a.codeOSC < b.codeOSC )
             return -1;
         if ( a.codeOSC > b.codeOSC )
             return 1;
         return 0;
    });
  
  var maxStep = 0;	
  if (nrCodes > 2) {  
	// get maximum step size
    maxStep = oscObjAvg[1].codeOSC - oscObjAvg[0].codeOSC;	
	var minOSC = oscObjAvg[0].codeOSC;
	var maxOSC = oscObjAvg[oscObjAvg.length - 1].codeOSC;
	for (var j = 2; j < nrCodes; j++) { 	   // Getr maximum step size
      var stepOSCX = oscObjAvg[j].codeOSC - oscObjAvg[j-1].codeOSC;	
	  if (stepOSCX > maxStep) maxStep = stepOSCX;
	}
  }	
// make ideal curve lookup table
// maximum step = 0.5..1.5 LSB
  var stepScale = parseFloat(document.getElementById("stepScale").value);  // number of code values
    maxStep = stepScale * maxStep;
  if (maxStep == 0 ) { alert("maxStep = 0"); }
  else {  // maxStep not 0
   var maxCodes = (maxOSC - minOSC) / maxStep;
// Look for suitable values going through sorted array
   var lookupList = [];
   lookupList[0] = oscObjAvg[0].codeAWG;
   var nextVal = oscObjAvg[0].codeOSC + maxStep;
   var indexL = 1;
   lookupList[indexL] = oscObjAvg[1].codeAWG;
   var errorL = Math.abs(oscObjAvg[1].codeOSC - nextVal);
   for (var i = 2; i < nrCodes; i++) {   // get lookup list 
     var errorN = oscObjAvg[i].codeOSC - nextVal;
     if (errorN > 0.5 * maxStep) { // next value
	    indexL = indexL +1;
		nextVal = nextVal + maxStep;
		errorN = oscObjAvg[i].codeOSC - nextVal;
		errorL = Math.abs(errorN);
        lookupList[indexL] = oscObjAvg[i].codeAWG;
     }	 
	 if (Math.abs(errorN) < errorL) {   // absolute error better
        lookupList[indexL] = oscObjAvg[i].codeAWG;
		errorL = Math.abs(errorN);
	 }
   }				
   var rangeN = indexL;   
   for (var i = indexL + 1; i < 8 * 1024; i++) {   // fill up rest until 8k 
      lookupList[i] = oscObjAvg[nrCodes-1].codeAWG;
   }
   for (var i = 0; i < 4 * 1024; i++) {   // copy lower 4k to upper 4k: 8k 
      lookupList[i + 4*1024] = lookupList[i];
   }

   var lText = "Min: " + oscObjAvg[0].codeOSC + " Max: " + oscObjAvg[nrCodes-1].codeOSC 
              + " Step: " + maxStep + " New Codes: " + rangeN 
			  + " New Code Range: " + (rangeN * 16) + "<br>\n";
   lText += "Lookup Table: <br>\n";
   var xText = lText;  
   for (var i = 0; i < 16 * 4 * 8; i++) {   // fill up rest 
      for (var j = 0; j < 16; j++) {   // fill up rest 
         lText += lookupList[i * 16 + j] + ",";
		 xText += lookupList[i * 16 + j] + ",";
      }
	  lText = lText + "<br>\n";
	  xText = xText +"\n";
   }
   xText = xText.substring(0, xText.length-2);
   document.getElementById("bestL").innerHTML = lText;
   document.getElementById("lookupX").value = xText;
   // calculate new INL, DNL and redo with different maxStep if necessary
  
  } // End maxStep not 0
}

//----------------------------------------------------------------------------------//
//-------------------- Lookup Table ---------------------------------------------//
//----------------------------------------------------------------------------------//

function sendLookup() {
 var nrVal = 8 * 1024;
 deactivateLookup();  // address multiplexing between AWG and UART ??
 var lookupText = lookupX.value; // get string
 // convert string to hex values
 var cmdText = "";
 lookupText = lookupText.replace(/(\r\n|\n|\r)/gm,""); // remove carriage return
 lookupText = lookupText.replace(/" "/gm,"");          // remove spaces
 var lookupArr = lookupText.split(",");                // make array
 while (lookupArr.length < nrVal) {  // fill up to 8k values
     lookupArr.push(0);
 }
 for (var i = 0; i < nrVal; i++) { 	// convert all values to hex
   cmdText = cmdText + decToHex(parseInt(lookupArr[i]),4);
 } 

  cmdText = "R" + cmdText; //
 // sendCmd "R" data
  document.getElementById("cmd").innerHTML = cmdText;
  sendCmd();
}

function defaultLookup(md) {
 var nrVal = 8 * 1024;
 deactivateLookup(); // address multiplexing between AWG and UART ??
 // convert string to hex values
 var cmdText = "";
 var lookupText = "";
 var fixed = parseInt(document.getElementById("lookupVal").value);
 for (var i = 0; i < nrVal; i++) { 	// convert all values to hex
   var k = i * 16;                   // upscale to 64 k 
   if (md == 1) k = 8 *1024 - 1 - i * 16; // reverse 
   if (md == 2) k = fixed;                 
   if (md == 3) k = Math.trunc(i / 128) * 128 * 16; // 128 gives 32 levels                 
   k = k % (64 * 1024);                  // maximum 16 bit
   cmdText = cmdText + decToHex(k,4);
   lookupText = lookupText + k + ",";
 } 
 lookupX.value = lookupText;
 // sendCmd "R" data
  cmdText = "R" + cmdText; // Some problems with VHDL?! .substring(1)
  document.getElementById("cmd").innerHTML = cmdText;
  sendCmd();
}

function activateLookup() {
 // send X command
  document.getElementById("cmd").innerHTML = "Q";
  sendCmd();
}

function deactivateLookup() {
 // send X command
  document.getElementById("cmd").innerHTML = "X";
  sendCmd();
  if (aState == "Run") { // Keep AWG running 
	// Action 
    genCmdAWG();      // update command
	// check simulation?
	sendCmd();        // send command
  }
}

//----------------------------------------------------------------------------------//
//-------------------- NodeJS commands ---------------------------------------------//
//----------------------------------------------------------------------------------//

var socket = io.connect();
 
var fullDataT = "";
 
        socket.on('newData', function (data) {                  // get from server all data
            var rVal="";
			var dataX = "";
			var dataY = data.value;
			dataOSC = [];
			dataOSC1 = [];
			dataOSC2 = [];
			dataOSC3 = [];
			document.getElementById("data").innerHTML = dataY + "<br>" + hexToDec(dataX.substring(1+2*4,5+2*4));
			  // example dataY: U4710FF0F471000000000Y   dataY:X0000000000000000D119Y
			  dataX = dataY;  // fixed in uart_TX
			  //for (var i = dataY.length - 1; i >= 0 ; i--) { // bring in right order addr 4,3,2,1,0 awg,c4,c3,c2,c1
			  //    dataX += dataY.substring(i,i+1);
			  //}
			if  (dataY[0] == "U") { // current acquisition position stored first ok??
			   currCon = hexToDec(dataX.substring(1+2*4,5+2*4));
			   currCon = currCon % dataMax; 
			   dataIndex = 1;
			   currCon = currCon + 1;
			   // alert(currCon);
            } 
			// dataOSC = [];
			// dataOSC.length = (dataMax -1) * 5; 
			for (var j = 1; j < dataMax ;j ++) { // length:dataMax-1 starting 0..511	
			  dataOSC[dataIndex - 1] = dataIndex - 1;
			  // fullDataT += dataY;
			  for (var i = 0; i < 5; i++) {
			     var sVal = dataX.substring(j * 22 + 1+(4-i)*4,j * 22 + 5+(4-i)*4);  // indexStart, indexEnd	
                 // alert(sVal);			   
			     rVal += sVal +"," + hexToDec(sVal) + ","; // ;
				 // store scaled data
				 dataOSC[dataIndex - 1 + (dataMax -1) * (i+1)] = Math.trunc(hexToDec(sVal)); // store data in array
			  }
			  // document.getElementById("data").innerHTML = currCon + "," + dataIndex + "," + dataY.length + "," + 
			  //  dataX.length + "," + dataX + ": " + rVal;
			  dataIndex += 1;                                   // next set
	        }		
			  // Array dataOSC: 0,1,2..(dataMax-2) AWG1 0,1,2..(dataMax-2) OSC1 ..
			  dataOSC1 = [];
			  if (dataIndex == dataMax) {  // received dataMax data
			     // alert(fullDataT);
				 // sort data into dataOSC1 from currCon til end and start until currCon
				 // To Do: Individual Scale with ADC range and offset
				 for (var i = 0; i < (dataMax - 1); i++) {  // 512 Data block  size: samples, 0..510 (-first,-currCon)
			       if (i + currCon  + 1 < dataMax - 1) {
				    dataOSC1[i] = i;
				    dataOSC1[i + (dataMax-2)] = dataOSC[i + currCon + 1 + (dataMax-1)]; 
				    dataOSC1[i + 2 * (dataMax-2)] = dataOSC[i + currCon + 1 + 2 * (dataMax-1)];
				    dataOSC1[i + 3 * (dataMax-2)] = dataOSC[i + currCon + 1 + 3 * (dataMax-1)];
				    dataOSC1[i + 4 * (dataMax-2)] = dataOSC[i + currCon + 1 + 4 * (dataMax-1)];
				    dataOSC1[i + 5 * (dataMax-2)] = dataOSC[i + currCon + 1 + 5 * (dataMax-1)];
				   } else {
				     dataOSC1[i] = i ;
				     dataOSC1[i + (dataMax-2)] = dataOSC[i + currCon + 1 ];  // AWG 3.3V
				     dataOSC1[i + 2 * (dataMax-2)] = dataOSC[i + currCon + 1 + 1 * (dataMax-1)];
				     dataOSC1[i + 3 * (dataMax-2)] = dataOSC[i + currCon + 1 + 2 * (dataMax-1)];
				     dataOSC1[i + 4 * (dataMax-2)] = dataOSC[i + currCon + 1 + 3 * (dataMax-1)];
				     dataOSC1[i + 5 * (dataMax-2)] = dataOSC[i + currCon + 1 + 4 * (dataMax-1)];
                   }				   
				 }
				 // dataOSC1 0.. (dataMax-3)  dataMax-2 values
				 // Look for trigger 
				 var trg = parseInt(document.getElementById("trgSrc").value);       // Channel
				 var trgEdge = parseInt(document.getElementById("trgEdge").value);  // Edge
				 var trgLevel = unitToValue(document.getElementById("trigLevelVal").value); // Level
				 var factor = 1/(4*16*1024-1); // 1 V range XADC, 64k range
				 //
                 var boardX = parseInt(document.getElementById("board").value);
                 if (boardX == 2) { // Arduino
                   factor = 1/(4*1024-1);  // 12 Bit 3.3V??
				 }
				 
				 var offset = 0;
				 trgPos = -1;
				 var minVal = dataOSC1[Math.round(dataMax/4) + 4 + dataMax * trg]; // Start Position
				 for (var i = Math.round(dataMax/4) + 4; i < Math.round(3*dataMax/4) - 4; i++) { // prevent overflow
			       var val1 = dataOSC1[i + dataMax * trg] * factor + offset; 
				   var val2 = dataOSC1[i - 1 + dataMax * trg] * factor + offset; 
				   if (trg == 1) {
				       val1 = dataOSC1[i + dataMax * trg] * factor * 3.3 + offset; 
				       val2 = dataOSC1[i - 1 + dataMax * trg] * factor * 3.3 + offset; 
				   }
				   if  (trgEdge == 1) {       // rising
				      if ((val1 > val2) && (val1 >= trgLevel) && (trgLevel >= val2)) trgPos = i;
                   } else if (trgEdge == 2) { // falling
				      if ((val1 < val2) && (val1 <= trgLevel) && (trgLevel <= val2)) trgPos = i; 	
				   } else if (trgEdge == 3) { // ramp
				      if ((val1 <= minVal) && ( i < dataMax/2 - 1)) {
					    minVal = val1;
						trgPos = i + Math.round(dataMax/4);
                        // set correct trigger level in Volts
						document.getElementById("trigLevelVal").value = valueToUnit(dataOSC1[trgPos + dataMax * trg]);
					  }
                   }				   
				   // alert(val1 + "," + val2 + "," + trgLevel + "," + factor + "," + offset);
				 }
				 // alert(trgPos + "," + trgEdge + "," + trg + "," + (dataMax/4) + "," + factor + "," + offset);
				 // transfer triggered data
				 var triggered = "triggered";
				 if (trgPos < dataMax/4) {
				    trgPos = Math.round(dataMax/2);
				    triggered = "not triggered";
				 }
				 trgPos = trgPos - Math.round(dataMax/4);  // was /3 ??
				 var dataMax2 = Math.round(dataMax/2);
				 
				 var timeSampling = unitToValue(document.getElementById("timeSampling").value);
				 
				 var timestep = timeSampling * (timeBase + 1);     // XADC 10ns * 8 * 104 cycles conversion
				 
				 // voltage range AWG, OSC1, OSC2, OSC3, OSC4
				 var factorX = [3.3, 1.0, 1.0, 1.0, 1.0]; // FPGA Range
				 // if (currUnit == 0) { timestep = 1} 
                 if (boardX == 2) { // Arduino
                   factorX = [3.3, 1.0, 1.0, 1.0, 3.3];  // Arduino range with PMOD AD2
				 }
				 for (var i=0; i<factorX.length; i++) {
				    factorX[i] = factorX[i] * factor; 
				 }
			     for (var i = 0; i < dataMax2; i++) {
					dataOSC3[i] = i;
					dataOSC2[i] = (i - dataMax/4) * timestep;
			        dataOSC3[i + dataMax2] = dataOSC1[ i + trgPos + (dataMax - 2)];                         // AWG code
			        dataOSC2[i + dataMax2] = dataOSC1[ i + trgPos + (dataMax - 2)] * factorX[0] + offset; // AWG 3.3V
			        dataOSC3[i + 2 * dataMax2] = dataOSC1[ i + trgPos + 2 * (dataMax - 2)];
			        dataOSC2[i + 2 * dataMax2] = dataOSC1[ i + trgPos + 2 * (dataMax - 2)] * factorX[1] + offset;
			        dataOSC3[i + 3 * dataMax2] = dataOSC1[ i + trgPos + 3 * (dataMax - 2)];
			        dataOSC2[i + 3 * dataMax2] = dataOSC1[ i + trgPos + 3 * (dataMax - 2)] * factorX[2] + offset;
			        dataOSC3[i + 4 * dataMax2] = dataOSC1[ i + trgPos + 4 * (dataMax - 2)];
			        dataOSC2[i + 4 * dataMax2] = dataOSC1[ i + trgPos + 4 * (dataMax - 2)] * factorX[3] + offset;
			        dataOSC3[i + 5 * dataMax2] = dataOSC1[ i + trgPos + 5 * (dataMax - 2)];
			        dataOSC2[i + 5 * dataMax2] = dataOSC1[ i + trgPos + 5 * (dataMax - 2)] * factorX[4] + offset;
				 }
				 // ready to plot
                 // ScatterPlot("OSC","Oszilloskop",dataOSC2,dataMax2,
		         //            "time","lin","Minmax",
			     //            "Amplitude","lin","auto","Fine");
				 updatePlot();
   		         chanStats();

				let now = new Date();
                let nowTxt = now.getFullYear() + "/" + (now.getMonth()+1)
                           + "/" + now.getDate() + " " + now.getHours()
						   + ":" + now.getMinutes() + ":" + now.getSeconds()+ "." + now.getMilliseconds();			
				// 1 Msps 8 samples per point 1E6/8						
				document.getElementById("statusOSC").innerHTML = triggered + " " + nowTxt + " " + dataMax2 + " samples at " 
				   + valueToUnit(1/timestep) + "Hz/" + valueToUnit(timestep) + "s";
				dataIndex = 0;	
				// do FFT
				if (fState == "Run") {
				  generateFFT();
				}
				// do INL DNL
				if (rState == "Run") {
				   nextRamp();
				}
				
			   } //---------------------- End of received data processing ------------------>
			   busyOsc = 0;
        });
        
        function sendCmd()   // filename fName send to server
        {
            var cmd = document.getElementById("cmd").innerHTML ;
			// if (cmd="U") alert("Tx");
            socket.emit('cmd', { value: cmd });
        }
		
        function sendCmdC()   // filename fName send to server
        {
			var cmd = document.getElementById("cmdTxt").value;
			try {
			  socket.emit('cmd', { value: cmd });
			} catch (error) { console.error(error); }
			let now = new Date();
            let nowTxt = now.getFullYear() + "/" + (now.getMonth()+1)
                           + "/" + now.getDate() + " " + now.getHours()
						   + ":" + now.getMinutes() + ":" + now.getSeconds()+ "." + now.getMilliseconds();			
			document.getElementById("lCmd").innerHTML = "Sent command: " + cmd + " at " + nowTxt;
        }

function initAll() {
   changeUnit();
}

window.addEventListener("load",confOsc());
window.addEventListener("load",initAll());

		// Will pop up regularly
		// socket.on("connect_error", (error) => {
           // ...
		//   alert("connect error");
        // });
	
</script>
	
	
	</body>
	</html>